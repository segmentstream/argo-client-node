// tslint:disable
/**
 * Argo
 * Argo
 *
 * The version of the OpenAPI document: v2.7.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ArchiveStrategy
 */
export interface ArchiveStrategy {
    /**
     * NoneStrategy indicates to skip tar process and upload the files or directory tree as independent files. Note that if the artifact is a directory, the artifact driver must support the ability to save/load the directory appropriately.
     * @type {object}
     * @memberof ArchiveStrategy
     */
    none?: object;
    /**
     * 
     * @type {object}
     * @memberof ArchiveStrategy
     */
    tar?: object;
}
/**
 * 
 * @export
 * @interface Arguments
 */
export interface Arguments {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Arguments
     */
    artifacts?: Array<Artifact>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Arguments
     */
    parameters?: Array<Parameter>;
}
/**
 * 
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * 
     * @type {ArchiveStrategy}
     * @memberof Artifact
     */
    archive?: ArchiveStrategy;
    /**
     * 
     * @type {ArtifactLocation}
     * @memberof Artifact
     */
    artifactLocation?: ArtifactLocation;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    globalName?: string;
    /**
     * mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts.
     * @type {number}
     * @memberof Artifact
     */
    mode?: number;
    /**
     * name of the artifact. must be unique within a template\'s inputs/outputs.
     * @type {string}
     * @memberof Artifact
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Artifact
     */
    optional?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    path?: string;
}
/**
 * ArtifactLocation describes a location for a single or multiple artifacts. It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname). It is also used to describe the location of multiple artifacts such as the archive location of a single workflow step, which the executor will use as a default location to store its files.
 * @export
 * @interface ArtifactLocation
 */
export interface ArtifactLocation {
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactLocation
     */
    archiveLogs?: boolean;
    /**
     * 
     * @type {ArtifactoryArtifact}
     * @memberof ArtifactLocation
     */
    artifactory?: ArtifactoryArtifact;
    /**
     * 
     * @type {GCSArtifact}
     * @memberof ArtifactLocation
     */
    gcs?: GCSArtifact;
    /**
     * 
     * @type {GitArtifact}
     * @memberof ArtifactLocation
     */
    git?: GitArtifact;
    /**
     * 
     * @type {HDFSArtifact}
     * @memberof ArtifactLocation
     */
    hdfs?: HDFSArtifact;
    /**
     * 
     * @type {HTTPArtifact}
     * @memberof ArtifactLocation
     */
    http?: HTTPArtifact;
    /**
     * 
     * @type {OSSArtifact}
     * @memberof ArtifactLocation
     */
    oss?: OSSArtifact;
    /**
     * 
     * @type {RawArtifact}
     * @memberof ArtifactLocation
     */
    raw?: RawArtifact;
    /**
     * 
     * @type {S3Artifact}
     * @memberof ArtifactLocation
     */
    s3?: S3Artifact;
}
/**
 * 
 * @export
 * @interface ArtifactRepositoryRef
 */
export interface ArtifactRepositoryRef {
    /**
     * 
     * @type {string}
     * @memberof ArtifactRepositoryRef
     */
    configMap?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactRepositoryRef
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface ArtifactoryArtifact
 */
export interface ArtifactoryArtifact {
    /**
     * 
     * @type {ArtifactoryAuth}
     * @memberof ArtifactoryArtifact
     */
    artifactoryAuth?: ArtifactoryAuth;
    /**
     * 
     * @type {string}
     * @memberof ArtifactoryArtifact
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ArtifactoryAuth
 */
export interface ArtifactoryAuth {
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof ArtifactoryAuth
     */
    passwordSecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof ArtifactoryAuth
     */
    usernameSecret?: IoK8sApiCoreV1SecretKeySelector;
}
/**
 * 
 * @export
 * @interface Backoff
 */
export interface Backoff {
    /**
     * 
     * @type {string}
     * @memberof Backoff
     */
    duration?: string;
    /**
     * 
     * @type {number}
     * @memberof Backoff
     */
    factor?: number;
    /**
     * 
     * @type {string}
     * @memberof Backoff
     */
    maxDuration?: string;
}
/**
 * ContinueOn defines if a workflow should continue even if a task or step fails/errors. It can be specified if the workflow should continue when the pod errors, fails or both.
 * @export
 * @interface ContinueOn
 */
export interface ContinueOn {
    /**
     * 
     * @type {boolean}
     * @memberof ContinueOn
     */
    error?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContinueOn
     */
    failed?: boolean;
}
/**
 * 
 * @export
 * @interface Counter
 */
export interface Counter {
    /**
     * 
     * @type {string}
     * @memberof Counter
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface CronCreateCronWorkflowRequest
 */
export interface CronCreateCronWorkflowRequest {
    /**
     * 
     * @type {IoK8sApiCoreV1CreateOptions}
     * @memberof CronCreateCronWorkflowRequest
     */
    createOptions?: IoK8sApiCoreV1CreateOptions;
    /**
     * 
     * @type {CronWorkflow}
     * @memberof CronCreateCronWorkflowRequest
     */
    cronWorkflow?: CronWorkflow;
    /**
     * 
     * @type {string}
     * @memberof CronCreateCronWorkflowRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface CronLintCronWorkflowRequest
 */
export interface CronLintCronWorkflowRequest {
    /**
     * 
     * @type {CronWorkflow}
     * @memberof CronLintCronWorkflowRequest
     */
    cronWorkflow?: CronWorkflow;
    /**
     * 
     * @type {string}
     * @memberof CronLintCronWorkflowRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface CronUpdateCronWorkflowRequest
 */
export interface CronUpdateCronWorkflowRequest {
    /**
     * 
     * @type {CronWorkflow}
     * @memberof CronUpdateCronWorkflowRequest
     */
    cronWorkflow?: CronWorkflow;
    /**
     * 
     * @type {string}
     * @memberof CronUpdateCronWorkflowRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CronUpdateCronWorkflowRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface CronWorkflow
 */
export interface CronWorkflow {
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectMeta}
     * @memberof CronWorkflow
     */
    metadata?: IoK8sApiCoreV1ObjectMeta;
    /**
     * 
     * @type {CronWorkflowSpec}
     * @memberof CronWorkflow
     */
    spec?: CronWorkflowSpec;
    /**
     * 
     * @type {CronWorkflowStatus}
     * @memberof CronWorkflow
     */
    status?: CronWorkflowStatus;
}
/**
 * 
 * @export
 * @interface CronWorkflowList
 */
export interface CronWorkflowList {
    /**
     * 
     * @type {Array<CronWorkflow>}
     * @memberof CronWorkflowList
     */
    items?: Array<CronWorkflow>;
    /**
     * 
     * @type {IoK8sApiCoreV1ListMeta}
     * @memberof CronWorkflowList
     */
    metadata?: IoK8sApiCoreV1ListMeta;
}
/**
 * 
 * @export
 * @interface CronWorkflowSpec
 */
export interface CronWorkflowSpec {
    /**
     * 
     * @type {string}
     * @memberof CronWorkflowSpec
     */
    concurrencyPolicy?: string;
    /**
     * 
     * @type {number}
     * @memberof CronWorkflowSpec
     */
    failedJobsHistoryLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof CronWorkflowSpec
     */
    schedule?: string;
    /**
     * StartingDeadlineSeconds is the K8s-style deadline that will limit the time a CronWorkflow will be run after its original scheduled time if it is missed.
     * @type {string}
     * @memberof CronWorkflowSpec
     */
    startingDeadlineSeconds?: string;
    /**
     * 
     * @type {number}
     * @memberof CronWorkflowSpec
     */
    successfulJobsHistoryLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CronWorkflowSpec
     */
    suspend?: boolean;
    /**
     * Timezone is the timezone against which the cron schedule will be calculated, e.g. \"Asia/Tokyo\". Default is machine\'s local time.
     * @type {string}
     * @memberof CronWorkflowSpec
     */
    timezone?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectMeta}
     * @memberof CronWorkflowSpec
     */
    workflowMeta?: IoK8sApiCoreV1ObjectMeta;
    /**
     * 
     * @type {WorkflowSpec}
     * @memberof CronWorkflowSpec
     */
    workflowSpec?: WorkflowSpec;
}
/**
 * 
 * @export
 * @interface CronWorkflowStatus
 */
export interface CronWorkflowStatus {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1ObjectReference>}
     * @memberof CronWorkflowStatus
     */
    active?: Array<IoK8sApiCoreV1ObjectReference>;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof CronWorkflowStatus
     */
    lastScheduledTime?: IoK8sApiCoreV1Time;
}
/**
 * 
 * @export
 * @interface DAGTask
 */
export interface DAGTask {
    /**
     * 
     * @type {Arguments}
     * @memberof DAGTask
     */
    arguments?: Arguments;
    /**
     * 
     * @type {ContinueOn}
     * @memberof DAGTask
     */
    continueOn?: ContinueOn;
    /**
     * 
     * @type {Array<string>}
     * @memberof DAGTask
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DAGTask
     */
    name?: string;
    /**
     * OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template.
     * @type {string}
     * @memberof DAGTask
     */
    onExit?: string;
    /**
     * 
     * @type {string}
     * @memberof DAGTask
     */
    template?: string;
    /**
     * 
     * @type {TemplateRef}
     * @memberof DAGTask
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {string}
     * @memberof DAGTask
     */
    when?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof DAGTask
     */
    withItems?: Array<Item>;
    /**
     * WithParam expands a task into multiple parallel tasks from the value in the parameter, which is expected to be a JSON list.
     * @type {string}
     * @memberof DAGTask
     */
    withParam?: string;
    /**
     * 
     * @type {Sequence}
     * @memberof DAGTask
     */
    withSequence?: Sequence;
}
/**
 * 
 * @export
 * @interface DAGTemplate
 */
export interface DAGTemplate {
    /**
     * 
     * @type {boolean}
     * @memberof DAGTemplate
     */
    failFast?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DAGTemplate
     */
    target?: string;
    /**
     * 
     * @type {Array<DAGTask>}
     * @memberof DAGTemplate
     */
    tasks?: Array<DAGTask>;
}
/**
 * ExecutorConfig holds configurations of an executor container.
 * @export
 * @interface ExecutorConfig
 */
export interface ExecutorConfig {
    /**
     * ServiceAccountName specifies the service account name of the executor container.
     * @type {string}
     * @memberof ExecutorConfig
     */
    serviceAccountName?: string;
}
/**
 * 
 * @export
 * @interface GCSArtifact
 */
export interface GCSArtifact {
    /**
     * 
     * @type {GCSBucket}
     * @memberof GCSArtifact
     */
    gCSBucket?: GCSBucket;
    /**
     * 
     * @type {string}
     * @memberof GCSArtifact
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface GCSBucket
 */
export interface GCSBucket {
    /**
     * 
     * @type {string}
     * @memberof GCSBucket
     */
    bucket?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof GCSBucket
     */
    serviceAccountKeySecret?: IoK8sApiCoreV1SecretKeySelector;
}
/**
 * 
 * @export
 * @interface Gauge
 */
export interface Gauge {
    /**
     * 
     * @type {boolean}
     * @memberof Gauge
     */
    realtime?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Gauge
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GitArtifact
 */
export interface GitArtifact {
    /**
     * 
     * @type {string}
     * @memberof GitArtifact
     */
    depth?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GitArtifact
     */
    fetch?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof GitArtifact
     */
    insecureIgnoreHostKey?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof GitArtifact
     */
    passwordSecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {string}
     * @memberof GitArtifact
     */
    repo?: string;
    /**
     * 
     * @type {string}
     * @memberof GitArtifact
     */
    revision?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof GitArtifact
     */
    sshPrivateKeySecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof GitArtifact
     */
    usernameSecret?: IoK8sApiCoreV1SecretKeySelector;
}
/**
 * 
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeStreamError
 */
export interface GrpcGatewayRuntimeStreamError {
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    details?: Array<GoogleProtobufAny>;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    grpc_code?: number;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    http_code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    http_status?: string;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface HDFSArtifact
 */
export interface HDFSArtifact {
    /**
     * 
     * @type {boolean}
     * @memberof HDFSArtifact
     */
    force?: boolean;
    /**
     * 
     * @type {HDFSConfig}
     * @memberof HDFSArtifact
     */
    hDFSConfig?: HDFSConfig;
    /**
     * 
     * @type {string}
     * @memberof HDFSArtifact
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface HDFSConfig
 */
export interface HDFSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof HDFSConfig
     */
    addresses?: Array<string>;
    /**
     * 
     * @type {HDFSKrbConfig}
     * @memberof HDFSConfig
     */
    hDFSKrbConfig?: HDFSKrbConfig;
    /**
     * HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.
     * @type {string}
     * @memberof HDFSConfig
     */
    hdfsUser?: string;
}
/**
 * 
 * @export
 * @interface HDFSKrbConfig
 */
export interface HDFSKrbConfig {
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof HDFSKrbConfig
     */
    krbCCacheSecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {IoK8sApiCoreV1ConfigMapKeySelector}
     * @memberof HDFSKrbConfig
     */
    krbConfigConfigMap?: IoK8sApiCoreV1ConfigMapKeySelector;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof HDFSKrbConfig
     */
    krbKeytabSecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.
     * @type {string}
     * @memberof HDFSKrbConfig
     */
    krbRealm?: string;
    /**
     * KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.
     * @type {string}
     * @memberof HDFSKrbConfig
     */
    krbServicePrincipalName?: string;
    /**
     * KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.
     * @type {string}
     * @memberof HDFSKrbConfig
     */
    krbUsername?: string;
}
/**
 * 
 * @export
 * @interface HTTPArtifact
 */
export interface HTTPArtifact {
    /**
     * 
     * @type {string}
     * @memberof HTTPArtifact
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Histogram
 */
export interface Histogram {
    /**
     * 
     * @type {Array<number>}
     * @memberof Histogram
     */
    buckets?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Histogram
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InfoResponse
 */
export interface InfoResponse {
    /**
     * 
     * @type {Array<Link>}
     * @memberof InfoResponse
     */
    links?: Array<Link>;
    /**
     * 
     * @type {string}
     * @memberof InfoResponse
     */
    managedNamespace?: string;
}
/**
 * 
 * @export
 * @interface Inputs
 */
export interface Inputs {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Inputs
     */
    artifacts?: Array<Artifact>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Inputs
     */
    parameters?: Array<Parameter>;
}
/**
 * Represents a Persistent Disk resource in AWS.  An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
 */
export interface IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    volumeID?: string;
}
/**
 * Affinity is a group of affinity scheduling rules.
 * @export
 * @interface IoK8sApiCoreV1Affinity
 */
export interface IoK8sApiCoreV1Affinity {
    /**
     * 
     * @type {IoK8sApiCoreV1NodeAffinity}
     * @memberof IoK8sApiCoreV1Affinity
     */
    nodeAffinity?: IoK8sApiCoreV1NodeAffinity;
    /**
     * 
     * @type {IoK8sApiCoreV1PodAffinity}
     * @memberof IoK8sApiCoreV1Affinity
     */
    podAffinity?: IoK8sApiCoreV1PodAffinity;
    /**
     * 
     * @type {IoK8sApiCoreV1PodAntiAffinity}
     * @memberof IoK8sApiCoreV1Affinity
     */
    podAntiAffinity?: IoK8sApiCoreV1PodAntiAffinity;
}
/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * @export
 * @interface IoK8sApiCoreV1AzureDiskVolumeSource
 */
export interface IoK8sApiCoreV1AzureDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    cachingMode?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    diskName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    diskURI?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    kind?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1AzureDiskVolumeSource
     */
    readOnly?: boolean;
}
/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * @export
 * @interface IoK8sApiCoreV1AzureFileVolumeSource
 */
export interface IoK8sApiCoreV1AzureFileVolumeSource {
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1AzureFileVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureFileVolumeSource
     */
    secretName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1AzureFileVolumeSource
     */
    shareName?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1CSIVolumeSource
 */
export interface IoK8sApiCoreV1CSIVolumeSource {
    /**
     * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
     * @type {string}
     * @memberof IoK8sApiCoreV1CSIVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1CSIVolumeSource
     */
    nodePublishSecretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1CSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IoK8sApiCoreV1CSIVolumeSource
     */
    volumeAttributes?: { [key: string]: string; };
}
/**
 * Adds and removes POSIX capabilities from running containers.
 * @export
 * @interface IoK8sApiCoreV1Capabilities
 */
export interface IoK8sApiCoreV1Capabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1Capabilities
     */
    add?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1Capabilities
     */
    drop?: Array<string>;
}
/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1CephFSVolumeSource
 */
export interface IoK8sApiCoreV1CephFSVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    secretFile?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CephFSVolumeSource
     */
    user?: string;
}
/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1CinderVolumeSource
 */
export interface IoK8sApiCoreV1CinderVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CinderVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1CinderVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1CinderVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CinderVolumeSource
     */
    volumeID?: string;
}
/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.  The contents of the target ConfigMap\'s Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface IoK8sApiCoreV1ConfigMapEnvSource
 */
export interface IoK8sApiCoreV1ConfigMapEnvSource {
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ConfigMapEnvSource
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ConfigMapEnvSource
     */
    optional?: boolean;
}
/**
 * Selects a key from a ConfigMap.
 * @export
 * @interface IoK8sApiCoreV1ConfigMapKeySelector
 */
export interface IoK8sApiCoreV1ConfigMapKeySelector {
    /**
     * The key to select.
     * @type {string}
     * @memberof IoK8sApiCoreV1ConfigMapKeySelector
     */
    key?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ConfigMapKeySelector
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ConfigMapKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a projected volume.  The contents of the target ConfigMap\'s Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 * @export
 * @interface IoK8sApiCoreV1ConfigMapProjection
 */
export interface IoK8sApiCoreV1ConfigMapProjection {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1KeyToPath>}
     * @memberof IoK8sApiCoreV1ConfigMapProjection
     */
    items?: Array<IoK8sApiCoreV1KeyToPath>;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ConfigMapProjection
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ConfigMapProjection
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a volume.  The contents of the target ConfigMap\'s Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1ConfigMapVolumeSource
 */
export interface IoK8sApiCoreV1ConfigMapVolumeSource {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1ConfigMapVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1KeyToPath>}
     * @memberof IoK8sApiCoreV1ConfigMapVolumeSource
     */
    items?: Array<IoK8sApiCoreV1KeyToPath>;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ConfigMapVolumeSource
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ConfigMapVolumeSource
     */
    optional?: boolean;
}
/**
 * A single application container that you want to run within a pod.
 * @export
 * @interface IoK8sApiCoreV1Container
 */
export interface IoK8sApiCoreV1Container {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1Container
     */
    args?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1Container
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1EnvVar>}
     * @memberof IoK8sApiCoreV1Container
     */
    env?: Array<IoK8sApiCoreV1EnvVar>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1EnvFromSource>}
     * @memberof IoK8sApiCoreV1Container
     */
    envFrom?: Array<IoK8sApiCoreV1EnvFromSource>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Lifecycle}
     * @memberof IoK8sApiCoreV1Container
     */
    lifecycle?: IoK8sApiCoreV1Lifecycle;
    /**
     * 
     * @type {IoK8sApiCoreV1Probe}
     * @memberof IoK8sApiCoreV1Container
     */
    livenessProbe?: IoK8sApiCoreV1Probe;
    /**
     * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    name?: string;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1ContainerPort>}
     * @memberof IoK8sApiCoreV1Container
     */
    ports?: Array<IoK8sApiCoreV1ContainerPort>;
    /**
     * 
     * @type {IoK8sApiCoreV1Probe}
     * @memberof IoK8sApiCoreV1Container
     */
    readinessProbe?: IoK8sApiCoreV1Probe;
    /**
     * 
     * @type {IoK8sApiCoreV1ResourceRequirements}
     * @memberof IoK8sApiCoreV1Container
     */
    resources?: IoK8sApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {IoK8sApiCoreV1SecurityContext}
     * @memberof IoK8sApiCoreV1Container
     */
    securityContext?: IoK8sApiCoreV1SecurityContext;
    /**
     * 
     * @type {IoK8sApiCoreV1Probe}
     * @memberof IoK8sApiCoreV1Container
     */
    startupProbe?: IoK8sApiCoreV1Probe;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1Container
     */
    stdin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1Container
     */
    stdinOnce?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    terminationMessagePath?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    terminationMessagePolicy?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1Container
     */
    tty?: boolean;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1VolumeDevice>}
     * @memberof IoK8sApiCoreV1Container
     */
    volumeDevices?: Array<IoK8sApiCoreV1VolumeDevice>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1VolumeMount>}
     * @memberof IoK8sApiCoreV1Container
     */
    volumeMounts?: Array<IoK8sApiCoreV1VolumeMount>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Container
     */
    workingDir?: string;
}
/**
 * ContainerPort represents a network port in a single container.
 * @export
 * @interface IoK8sApiCoreV1ContainerPort
 */
export interface IoK8sApiCoreV1ContainerPort {
    /**
     * Number of port to expose on the pod\'s IP address. This must be a valid port number, 0 < x < 65536.
     * @type {number}
     * @memberof IoK8sApiCoreV1ContainerPort
     */
    containerPort?: number;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ContainerPort
     */
    hostIP?: string;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1ContainerPort
     */
    hostPort?: number;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ContainerPort
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ContainerPort
     */
    protocol?: string;
}
/**
 * CreateOptions may be provided when creating an API object.
 * @export
 * @interface IoK8sApiCoreV1CreateOptions
 */
export interface IoK8sApiCoreV1CreateOptions {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1CreateOptions
     */
    dryRun?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1CreateOptions
     */
    fieldManager?: string;
}
/**
 * DeleteOptions may be provided when deleting an API object.
 * @export
 * @interface IoK8sApiCoreV1DeleteOptions
 */
export interface IoK8sApiCoreV1DeleteOptions {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1DeleteOptions
     */
    dryRun?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1DeleteOptions
     */
    gracePeriodSeconds?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1DeleteOptions
     */
    orphanDependents?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1Preconditions}
     * @memberof IoK8sApiCoreV1DeleteOptions
     */
    preconditions?: IoK8sApiCoreV1Preconditions;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1DeleteOptions
     */
    propagationPolicy?: string;
}
/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 * @export
 * @interface IoK8sApiCoreV1DownwardAPIProjection
 */
export interface IoK8sApiCoreV1DownwardAPIProjection {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1DownwardAPIVolumeFile>}
     * @memberof IoK8sApiCoreV1DownwardAPIProjection
     */
    items?: Array<IoK8sApiCoreV1DownwardAPIVolumeFile>;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1DownwardAPIVolumeFile
 */
export interface IoK8sApiCoreV1DownwardAPIVolumeFile {
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectFieldSelector}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeFile
     */
    fieldRef?: IoK8sApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeFile
     */
    mode?: number;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeFile
     */
    path?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1ResourceFieldSelector}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeFile
     */
    resourceFieldRef?: IoK8sApiCoreV1ResourceFieldSelector;
}
/**
 * DownwardAPIVolumeSource represents a volume containing downward API  Downward API volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1DownwardAPIVolumeSource
 */
export interface IoK8sApiCoreV1DownwardAPIVolumeSource {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1DownwardAPIVolumeFile>}
     * @memberof IoK8sApiCoreV1DownwardAPIVolumeSource
     */
    items?: Array<IoK8sApiCoreV1DownwardAPIVolumeFile>;
}
/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1EmptyDirVolumeSource
 */
export interface IoK8sApiCoreV1EmptyDirVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1EmptyDirVolumeSource
     */
    medium?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Quantity}
     * @memberof IoK8sApiCoreV1EmptyDirVolumeSource
     */
    sizeLimit?: IoK8sApiCoreV1Quantity;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1EnvFromSource
 */
export interface IoK8sApiCoreV1EnvFromSource {
    /**
     * 
     * @type {IoK8sApiCoreV1ConfigMapEnvSource}
     * @memberof IoK8sApiCoreV1EnvFromSource
     */
    configMapRef?: IoK8sApiCoreV1ConfigMapEnvSource;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1EnvFromSource
     */
    prefix?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretEnvSource}
     * @memberof IoK8sApiCoreV1EnvFromSource
     */
    secretRef?: IoK8sApiCoreV1SecretEnvSource;
}
/**
 * EnvVar represents an environment variable present in a Container.
 * @export
 * @interface IoK8sApiCoreV1EnvVar
 */
export interface IoK8sApiCoreV1EnvVar {
    /**
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * @type {string}
     * @memberof IoK8sApiCoreV1EnvVar
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1EnvVar
     */
    value?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1EnvVarSource}
     * @memberof IoK8sApiCoreV1EnvVar
     */
    valueFrom?: IoK8sApiCoreV1EnvVarSource;
}
/**
 * EnvVarSource represents a source for the value of an EnvVar.
 * @export
 * @interface IoK8sApiCoreV1EnvVarSource
 */
export interface IoK8sApiCoreV1EnvVarSource {
    /**
     * 
     * @type {IoK8sApiCoreV1ConfigMapKeySelector}
     * @memberof IoK8sApiCoreV1EnvVarSource
     */
    configMapKeyRef?: IoK8sApiCoreV1ConfigMapKeySelector;
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectFieldSelector}
     * @memberof IoK8sApiCoreV1EnvVarSource
     */
    fieldRef?: IoK8sApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {IoK8sApiCoreV1ResourceFieldSelector}
     * @memberof IoK8sApiCoreV1EnvVarSource
     */
    resourceFieldRef?: IoK8sApiCoreV1ResourceFieldSelector;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof IoK8sApiCoreV1EnvVarSource
     */
    secretKeyRef?: IoK8sApiCoreV1SecretKeySelector;
}
/**
 * ExecAction describes a \"run in container\" action.
 * @export
 * @interface IoK8sApiCoreV1ExecAction
 */
export interface IoK8sApiCoreV1ExecAction {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1ExecAction
     */
    command?: Array<string>;
}
/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1FCVolumeSource
 */
export interface IoK8sApiCoreV1FCVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1FCVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1FCVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1FCVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1FCVolumeSource
     */
    targetWWNs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1FCVolumeSource
     */
    wwids?: Array<string>;
}
/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.  Each key is either a \'.\' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: \'f:<name>\', where <name> is the name of a field in a struct, or key in a map \'v:<value>\', where <value> is the exact json formatted value of a list item \'i:<index>\', where <index> is position of a item in a list \'k:<keys>\', where <keys> is a map of  a list item\'s key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.  The exact format is defined in sigs.k8s.io/structured-merge-diff
 * @export
 * @interface IoK8sApiCoreV1FieldsV1
 */
export interface IoK8sApiCoreV1FieldsV1 {
    /**
     * Raw is the underlying serialization of this object.
     * @type {string}
     * @memberof IoK8sApiCoreV1FieldsV1
     */
    Raw?: string;
}
/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 * @export
 * @interface IoK8sApiCoreV1FlexVolumeSource
 */
export interface IoK8sApiCoreV1FlexVolumeSource {
    /**
     * Driver is the name of the driver to use for this volume.
     * @type {string}
     * @memberof IoK8sApiCoreV1FlexVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1FlexVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IoK8sApiCoreV1FlexVolumeSource
     */
    options?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1FlexVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1FlexVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
}
/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1FlockerVolumeSource
 */
export interface IoK8sApiCoreV1FlockerVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1FlockerVolumeSource
     */
    datasetName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1FlockerVolumeSource
     */
    datasetUUID?: string;
}
/**
 * Represents a Persistent Disk resource in Google Compute Engine.  A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1GCEPersistentDiskVolumeSource
 */
export interface IoK8sApiCoreV1GCEPersistentDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GCEPersistentDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1GCEPersistentDiskVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GCEPersistentDiskVolumeSource
     */
    pdName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1GCEPersistentDiskVolumeSource
     */
    readOnly?: boolean;
}
/**
 * GetOptions is the standard query options to the standard REST get call.
 * @export
 * @interface IoK8sApiCoreV1GetOptions
 */
export interface IoK8sApiCoreV1GetOptions {
    /**
     * When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\'s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @type {string}
     * @memberof IoK8sApiCoreV1GetOptions
     */
    resourceVersion?: string;
}
/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.  DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod\'s container.
 * @export
 * @interface IoK8sApiCoreV1GitRepoVolumeSource
 */
export interface IoK8sApiCoreV1GitRepoVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GitRepoVolumeSource
     */
    directory?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GitRepoVolumeSource
     */
    repository?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GitRepoVolumeSource
     */
    revision?: string;
}
/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1GlusterfsVolumeSource
 */
export interface IoK8sApiCoreV1GlusterfsVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GlusterfsVolumeSource
     */
    endpoints?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1GlusterfsVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1GlusterfsVolumeSource
     */
    readOnly?: boolean;
}
/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 * @export
 * @interface IoK8sApiCoreV1HTTPGetAction
 */
export interface IoK8sApiCoreV1HTTPGetAction {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HTTPGetAction
     */
    host?: string;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1HTTPHeader>}
     * @memberof IoK8sApiCoreV1HTTPGetAction
     */
    httpHeaders?: Array<IoK8sApiCoreV1HTTPHeader>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HTTPGetAction
     */
    path?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1IntOrString}
     * @memberof IoK8sApiCoreV1HTTPGetAction
     */
    port?: IoK8sApiCoreV1IntOrString;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HTTPGetAction
     */
    scheme?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1HTTPHeader
 */
export interface IoK8sApiCoreV1HTTPHeader {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HTTPHeader
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HTTPHeader
     */
    value?: string;
}
/**
 * Handler defines a specific action that should be taken TODO: pass structured data to these actions, and document that data here.
 * @export
 * @interface IoK8sApiCoreV1Handler
 */
export interface IoK8sApiCoreV1Handler {
    /**
     * 
     * @type {IoK8sApiCoreV1ExecAction}
     * @memberof IoK8sApiCoreV1Handler
     */
    exec?: IoK8sApiCoreV1ExecAction;
    /**
     * 
     * @type {IoK8sApiCoreV1HTTPGetAction}
     * @memberof IoK8sApiCoreV1Handler
     */
    httpGet?: IoK8sApiCoreV1HTTPGetAction;
    /**
     * 
     * @type {IoK8sApiCoreV1TCPSocketAction}
     * @memberof IoK8sApiCoreV1Handler
     */
    tcpSocket?: IoK8sApiCoreV1TCPSocketAction;
}
/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\'s hosts file.
 * @export
 * @interface IoK8sApiCoreV1HostAlias
 */
export interface IoK8sApiCoreV1HostAlias {
    /**
     * Hostnames for the above IP address.
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1HostAlias
     */
    hostnames?: Array<string>;
    /**
     * IP address of the host file entry.
     * @type {string}
     * @memberof IoK8sApiCoreV1HostAlias
     */
    ip?: string;
}
/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1HostPathVolumeSource
 */
export interface IoK8sApiCoreV1HostPathVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HostPathVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1HostPathVolumeSource
     */
    type?: string;
}
/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1ISCSIVolumeSource
 */
export interface IoK8sApiCoreV1ISCSIVolumeSource {
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    chapAuthDiscovery?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    chapAuthSession?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    initiatorName?: string;
    /**
     * Target iSCSI Qualified Name.
     * @type {string}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    iqn?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    iscsiInterface?: string;
    /**
     * iSCSI Target Lun number.
     * @type {number}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    portals?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
     * @type {string}
     * @memberof IoK8sApiCoreV1ISCSIVolumeSource
     */
    targetPortal?: string;
}
/**
 * +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true
 * @export
 * @interface IoK8sApiCoreV1IntOrString
 */
export interface IoK8sApiCoreV1IntOrString {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1IntOrString
     */
    intVal?: number;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1IntOrString
     */
    strVal?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1IntOrString
     */
    type?: string;
}
/**
 * Maps a string key to a path within a volume.
 * @export
 * @interface IoK8sApiCoreV1KeyToPath
 */
export interface IoK8sApiCoreV1KeyToPath {
    /**
     * The key to project.
     * @type {string}
     * @memberof IoK8sApiCoreV1KeyToPath
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1KeyToPath
     */
    mode?: number;
    /**
     * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \'..\'. May not start with the string \'..\'.
     * @type {string}
     * @memberof IoK8sApiCoreV1KeyToPath
     */
    path?: string;
}
/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 * @export
 * @interface IoK8sApiCoreV1LabelSelector
 */
export interface IoK8sApiCoreV1LabelSelector {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1LabelSelectorRequirement>}
     * @memberof IoK8sApiCoreV1LabelSelector
     */
    matchExpressions?: Array<IoK8sApiCoreV1LabelSelectorRequirement>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IoK8sApiCoreV1LabelSelector
     */
    matchLabels?: { [key: string]: string; };
}
/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface IoK8sApiCoreV1LabelSelectorRequirement
 */
export interface IoK8sApiCoreV1LabelSelectorRequirement {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1LabelSelectorRequirement
     */
    key?: string;
    /**
     * operator represents a key\'s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
     * @type {string}
     * @memberof IoK8sApiCoreV1LabelSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1LabelSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 * @export
 * @interface IoK8sApiCoreV1Lifecycle
 */
export interface IoK8sApiCoreV1Lifecycle {
    /**
     * 
     * @type {IoK8sApiCoreV1Handler}
     * @memberof IoK8sApiCoreV1Lifecycle
     */
    postStart?: IoK8sApiCoreV1Handler;
    /**
     * 
     * @type {IoK8sApiCoreV1Handler}
     * @memberof IoK8sApiCoreV1Lifecycle
     */
    preStop?: IoK8sApiCoreV1Handler;
}
/**
 * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 * @export
 * @interface IoK8sApiCoreV1ListMeta
 */
export interface IoK8sApiCoreV1ListMeta {
    /**
     * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
     * @type {string}
     * @memberof IoK8sApiCoreV1ListMeta
     */
    _continue?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListMeta
     */
    remainingItemCount?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListMeta
     */
    resourceVersion?: string;
    /**
     * selfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ListMeta
     */
    selfLink?: string;
}
/**
 * ListOptions is the query options to a standard REST list call.
 * @export
 * @interface IoK8sApiCoreV1ListOptions
 */
export interface IoK8sApiCoreV1ListOptions {
    /**
     * allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\'s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    allowWatchBookmarks?: boolean;
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    _continue?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    fieldSelector?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    labelSelector?: string;
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    limit?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    timeoutSeconds?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ListOptions
     */
    watch?: boolean;
}
/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 * @export
 * @interface IoK8sApiCoreV1LocalObjectReference
 */
export interface IoK8sApiCoreV1LocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1LocalObjectReference
     */
    name?: string;
}
/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 * @export
 * @interface IoK8sApiCoreV1ManagedFieldsEntry
 */
export interface IoK8sApiCoreV1ManagedFieldsEntry {
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    fieldsType?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1FieldsV1}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    fieldsV1?: IoK8sApiCoreV1FieldsV1;
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    manager?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are \'Apply\' and \'Update\'.
     * @type {string}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    operation?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1ManagedFieldsEntry
     */
    time?: IoK8sApiCoreV1Time;
}
/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1NFSVolumeSource
 */
export interface IoK8sApiCoreV1NFSVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1NFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1NFSVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1NFSVolumeSource
     */
    server?: string;
}
/**
 * Node affinity is a group of node affinity scheduling rules.
 * @export
 * @interface IoK8sApiCoreV1NodeAffinity
 */
export interface IoK8sApiCoreV1NodeAffinity {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PreferredSchedulingTerm>}
     * @memberof IoK8sApiCoreV1NodeAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<IoK8sApiCoreV1PreferredSchedulingTerm>;
    /**
     * 
     * @type {IoK8sApiCoreV1NodeSelector}
     * @memberof IoK8sApiCoreV1NodeAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: IoK8sApiCoreV1NodeSelector;
}
/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * @export
 * @interface IoK8sApiCoreV1NodeSelector
 */
export interface IoK8sApiCoreV1NodeSelector {
    /**
     * Required. A list of node selector terms. The terms are ORed.
     * @type {Array<IoK8sApiCoreV1NodeSelectorTerm>}
     * @memberof IoK8sApiCoreV1NodeSelector
     */
    nodeSelectorTerms?: Array<IoK8sApiCoreV1NodeSelectorTerm>;
}
/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface IoK8sApiCoreV1NodeSelectorRequirement
 */
export interface IoK8sApiCoreV1NodeSelectorRequirement {
    /**
     * The label key that the selector applies to.
     * @type {string}
     * @memberof IoK8sApiCoreV1NodeSelectorRequirement
     */
    key?: string;
    /**
     * Represents a key\'s relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
     * @type {string}
     * @memberof IoK8sApiCoreV1NodeSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1NodeSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 * @export
 * @interface IoK8sApiCoreV1NodeSelectorTerm
 */
export interface IoK8sApiCoreV1NodeSelectorTerm {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1NodeSelectorRequirement>}
     * @memberof IoK8sApiCoreV1NodeSelectorTerm
     */
    matchExpressions?: Array<IoK8sApiCoreV1NodeSelectorRequirement>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1NodeSelectorRequirement>}
     * @memberof IoK8sApiCoreV1NodeSelectorTerm
     */
    matchFields?: Array<IoK8sApiCoreV1NodeSelectorRequirement>;
}
/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 * @export
 * @interface IoK8sApiCoreV1ObjectFieldSelector
 */
export interface IoK8sApiCoreV1ObjectFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectFieldSelector
     */
    apiVersion?: string;
    /**
     * Path of the field to select in the specified API version.
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectFieldSelector
     */
    fieldPath?: string;
}
/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 * @export
 * @interface IoK8sApiCoreV1ObjectMeta
 */
export interface IoK8sApiCoreV1ObjectMeta {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    clusterName?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    creationTimestamp?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    deletionGracePeriodSeconds?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    deletionTimestamp?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    finalizers?: Array<string>;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    generateName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    generation?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    labels?: { [key: string]: string; };
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that  This is mostly for internal housekeeping, and users typically shouldn\'t need to set or understand this field. A workflow can be the user\'s name, a controller\'s name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<IoK8sApiCoreV1ManagedFieldsEntry>}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    managedFields?: Array<IoK8sApiCoreV1ManagedFieldsEntry>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    name?: string;
    /**
     * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    namespace?: string;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1OwnerReference>}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    ownerReferences?: Array<IoK8sApiCoreV1OwnerReference>;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    resourceVersion?: string;
    /**
     * SelfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    selfLink?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectMeta
     */
    uid?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1ObjectReference
 */
export interface IoK8sApiCoreV1ObjectReference {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    fieldPath?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ObjectReference
     */
    uid?: string;
}
/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 * @export
 * @interface IoK8sApiCoreV1OwnerReference
 */
export interface IoK8sApiCoreV1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    apiVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    blockOwnerDeletion?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    controller?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1OwnerReference
     */
    uid?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1PersistentVolumeClaim
 */
export interface IoK8sApiCoreV1PersistentVolumeClaim {
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectMeta}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaim
     */
    metadata?: IoK8sApiCoreV1ObjectMeta;
    /**
     * 
     * @type {IoK8sApiCoreV1PersistentVolumeClaimSpec}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaim
     */
    spec?: IoK8sApiCoreV1PersistentVolumeClaimSpec;
    /**
     * 
     * @type {IoK8sApiCoreV1PersistentVolumeClaimStatus}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaim
     */
    status?: IoK8sApiCoreV1PersistentVolumeClaimStatus;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1PersistentVolumeClaimCondition
 */
export interface IoK8sApiCoreV1PersistentVolumeClaimCondition {
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    lastProbeTime?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    lastTransitionTime?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimCondition
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1PersistentVolumeClaimSpec
 */
export interface IoK8sApiCoreV1PersistentVolumeClaimSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    accessModes?: Array<string>;
    /**
     * 
     * @type {IoK8sApiCoreV1TypedLocalObjectReference}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    dataSource?: IoK8sApiCoreV1TypedLocalObjectReference;
    /**
     * 
     * @type {IoK8sApiCoreV1ResourceRequirements}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    resources?: IoK8sApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {IoK8sApiCoreV1LabelSelector}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    selector?: IoK8sApiCoreV1LabelSelector;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    storageClassName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    volumeMode?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimSpec
     */
    volumeName?: string;
}
/**
 * PersistentVolumeClaimStatus is the current status of a persistent volume claim.
 * @export
 * @interface IoK8sApiCoreV1PersistentVolumeClaimStatus
 */
export interface IoK8sApiCoreV1PersistentVolumeClaimStatus {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimStatus
     */
    accessModes?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: IoK8sApiCoreV1Quantity; }}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimStatus
     */
    capacity?: { [key: string]: IoK8sApiCoreV1Quantity; };
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PersistentVolumeClaimCondition>}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimStatus
     */
    conditions?: Array<IoK8sApiCoreV1PersistentVolumeClaimCondition>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimStatus
     */
    phase?: string;
}
/**
 * PersistentVolumeClaimVolumeSource references the user\'s PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 * @export
 * @interface IoK8sApiCoreV1PersistentVolumeClaimVolumeSource
 */
export interface IoK8sApiCoreV1PersistentVolumeClaimVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimVolumeSource
     */
    claimName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PersistentVolumeClaimVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a Photon Controller persistent disk resource.
 * @export
 * @interface IoK8sApiCoreV1PhotonPersistentDiskVolumeSource
 */
export interface IoK8sApiCoreV1PhotonPersistentDiskVolumeSource {
    /**
     * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof IoK8sApiCoreV1PhotonPersistentDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PhotonPersistentDiskVolumeSource
     */
    pdID?: string;
}
/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 * @export
 * @interface IoK8sApiCoreV1PodAffinity
 */
export interface IoK8sApiCoreV1PodAffinity {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1WeightedPodAffinityTerm>}
     * @memberof IoK8sApiCoreV1PodAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<IoK8sApiCoreV1WeightedPodAffinityTerm>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PodAffinityTerm>}
     * @memberof IoK8sApiCoreV1PodAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<IoK8sApiCoreV1PodAffinityTerm>;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1PodAffinityTerm
 */
export interface IoK8sApiCoreV1PodAffinityTerm {
    /**
     * 
     * @type {IoK8sApiCoreV1LabelSelector}
     * @memberof IoK8sApiCoreV1PodAffinityTerm
     */
    labelSelector?: IoK8sApiCoreV1LabelSelector;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PodAffinityTerm
     */
    namespaces?: Array<string>;
    /**
     * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
     * @type {string}
     * @memberof IoK8sApiCoreV1PodAffinityTerm
     */
    topologyKey?: string;
}
/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 * @export
 * @interface IoK8sApiCoreV1PodAntiAffinity
 */
export interface IoK8sApiCoreV1PodAntiAffinity {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1WeightedPodAffinityTerm>}
     * @memberof IoK8sApiCoreV1PodAntiAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<IoK8sApiCoreV1WeightedPodAffinityTerm>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PodAffinityTerm>}
     * @memberof IoK8sApiCoreV1PodAntiAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<IoK8sApiCoreV1PodAffinityTerm>;
}
/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 * @export
 * @interface IoK8sApiCoreV1PodDNSConfig
 */
export interface IoK8sApiCoreV1PodDNSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PodDNSConfig
     */
    nameservers?: Array<string>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PodDNSConfigOption>}
     * @memberof IoK8sApiCoreV1PodDNSConfig
     */
    options?: Array<IoK8sApiCoreV1PodDNSConfigOption>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PodDNSConfig
     */
    searches?: Array<string>;
}
/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 * @export
 * @interface IoK8sApiCoreV1PodDNSConfigOption
 */
export interface IoK8sApiCoreV1PodDNSConfigOption {
    /**
     * Required.
     * @type {string}
     * @memberof IoK8sApiCoreV1PodDNSConfigOption
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodDNSConfigOption
     */
    value?: string;
}
/**
 * PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
 * @export
 * @interface IoK8sApiCoreV1PodDisruptionBudgetSpec
 */
export interface IoK8sApiCoreV1PodDisruptionBudgetSpec {
    /**
     * 
     * @type {IoK8sApiCoreV1IntOrString}
     * @memberof IoK8sApiCoreV1PodDisruptionBudgetSpec
     */
    maxUnavailable?: IoK8sApiCoreV1IntOrString;
    /**
     * 
     * @type {IoK8sApiCoreV1IntOrString}
     * @memberof IoK8sApiCoreV1PodDisruptionBudgetSpec
     */
    minAvailable?: IoK8sApiCoreV1IntOrString;
    /**
     * 
     * @type {IoK8sApiCoreV1LabelSelector}
     * @memberof IoK8sApiCoreV1PodDisruptionBudgetSpec
     */
    selector?: IoK8sApiCoreV1LabelSelector;
}
/**
 * PodLogOptions is the query options for a Pod\'s logs REST call.
 * @export
 * @interface IoK8sApiCoreV1PodLogOptions
 */
export interface IoK8sApiCoreV1PodLogOptions {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    container?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    follow?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    limitBytes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    previous?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    sinceSeconds?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    sinceTime?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    tailLines?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PodLogOptions
     */
    timestamps?: boolean;
}
/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 * @export
 * @interface IoK8sApiCoreV1PodSecurityContext
 */
export interface IoK8sApiCoreV1PodSecurityContext {
    /**
     * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR\'d with rw-rw----  If unset, the Kubelet will not modify the ownership and permissions of any volume. +optional
     * @type {string}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    fsGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SELinuxOptions}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    seLinuxOptions?: IoK8sApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    supplementalGroups?: Array<string>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1Sysctl>}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    sysctls?: Array<IoK8sApiCoreV1Sysctl>;
    /**
     * 
     * @type {IoK8sApiCoreV1WindowsSecurityContextOptions}
     * @memberof IoK8sApiCoreV1PodSecurityContext
     */
    windowsOptions?: IoK8sApiCoreV1WindowsSecurityContextOptions;
}
/**
 * PortworxVolumeSource represents a Portworx volume resource.
 * @export
 * @interface IoK8sApiCoreV1PortworxVolumeSource
 */
export interface IoK8sApiCoreV1PortworxVolumeSource {
    /**
     * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof IoK8sApiCoreV1PortworxVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1PortworxVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1PortworxVolumeSource
     */
    volumeID?: string;
}
/**
 * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
 * @export
 * @interface IoK8sApiCoreV1Preconditions
 */
export interface IoK8sApiCoreV1Preconditions {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Preconditions
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Preconditions
     */
    uid?: string;
}
/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it\'s a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 * @export
 * @interface IoK8sApiCoreV1PreferredSchedulingTerm
 */
export interface IoK8sApiCoreV1PreferredSchedulingTerm {
    /**
     * 
     * @type {IoK8sApiCoreV1NodeSelectorTerm}
     * @memberof IoK8sApiCoreV1PreferredSchedulingTerm
     */
    preference?: IoK8sApiCoreV1NodeSelectorTerm;
    /**
     * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
     * @type {number}
     * @memberof IoK8sApiCoreV1PreferredSchedulingTerm
     */
    weight?: number;
}
/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 * @export
 * @interface IoK8sApiCoreV1Probe
 */
export interface IoK8sApiCoreV1Probe {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1Probe
     */
    failureThreshold?: number;
    /**
     * 
     * @type {IoK8sApiCoreV1Handler}
     * @memberof IoK8sApiCoreV1Probe
     */
    handler?: IoK8sApiCoreV1Handler;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1Probe
     */
    initialDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1Probe
     */
    periodSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1Probe
     */
    successThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1Probe
     */
    timeoutSeconds?: number;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1ProjectedVolumeSource
 */
export interface IoK8sApiCoreV1ProjectedVolumeSource {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1ProjectedVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1VolumeProjection>}
     * @memberof IoK8sApiCoreV1ProjectedVolumeSource
     */
    sources?: Array<IoK8sApiCoreV1VolumeProjection>;
}
/**
 * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.  The serialization format is:  <quantity>        ::= <signedNumber><suffix>   (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.) <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html) <decimalSI>       ::= m | \"\" | k | M | G | T | P | E   (Note that 1024 = 1Ki but 1000 = 1k; I didn\'t choose the capitalization.) <decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>  No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.  When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.  Before serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:   a. No precision is lost   b. No fractional digits will be emitted   c. The exponent (or suffix) is as large as possible. The sign will be omitted unless the number is negative.  Examples:   1.5 will be serialized as \"1500m\"   1.5Gi will be serialized as \"1536Mi\"  Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.  Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don\'t diff.)  This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.  +protobuf=true +protobuf.embed=string +protobuf.options.marshal=false +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:deepcopy-gen=true +k8s:openapi-gen=true
 * @export
 * @interface IoK8sApiCoreV1Quantity
 */
export interface IoK8sApiCoreV1Quantity {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Quantity
     */
    string?: string;
}
/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1QuobyteVolumeSource
 */
export interface IoK8sApiCoreV1QuobyteVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    group?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    registry?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    tenant?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    user?: string;
    /**
     * Volume is a string that references an already created Quobyte volume by name.
     * @type {string}
     * @memberof IoK8sApiCoreV1QuobyteVolumeSource
     */
    volume?: string;
}
/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1RBDVolumeSource
 */
export interface IoK8sApiCoreV1RBDVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    keyring?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    pool?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1RBDVolumeSource
     */
    user?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1ResourceFieldSelector
 */
export interface IoK8sApiCoreV1ResourceFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ResourceFieldSelector
     */
    containerName?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Quantity}
     * @memberof IoK8sApiCoreV1ResourceFieldSelector
     */
    divisor?: IoK8sApiCoreV1Quantity;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ResourceFieldSelector
     */
    resource?: string;
}
/**
 * ResourceRequirements describes the compute resource requirements.
 * @export
 * @interface IoK8sApiCoreV1ResourceRequirements
 */
export interface IoK8sApiCoreV1ResourceRequirements {
    /**
     * 
     * @type {{ [key: string]: IoK8sApiCoreV1Quantity; }}
     * @memberof IoK8sApiCoreV1ResourceRequirements
     */
    limits?: { [key: string]: IoK8sApiCoreV1Quantity; };
    /**
     * 
     * @type {{ [key: string]: IoK8sApiCoreV1Quantity; }}
     * @memberof IoK8sApiCoreV1ResourceRequirements
     */
    requests?: { [key: string]: IoK8sApiCoreV1Quantity; };
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1SELinuxOptions
 */
export interface IoK8sApiCoreV1SELinuxOptions {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SELinuxOptions
     */
    level?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SELinuxOptions
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SELinuxOptions
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SELinuxOptions
     */
    user?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1ScaleIOVolumeSource
 */
export interface IoK8sApiCoreV1ScaleIOVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    fsType?: string;
    /**
     * The host address of the ScaleIO API Gateway.
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    gateway?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    protectionDomain?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    sslEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    storageMode?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    storagePool?: string;
    /**
     * The name of the storage system as configured in ScaleIO.
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    system?: string;
    /**
     * The name of a volume already created in the ScaleIO system that is associated with this volume source.
     * @type {string}
     * @memberof IoK8sApiCoreV1ScaleIOVolumeSource
     */
    volumeName?: string;
}
/**
 * SecretEnvSource selects a Secret to populate the environment variables with.  The contents of the target Secret\'s Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface IoK8sApiCoreV1SecretEnvSource
 */
export interface IoK8sApiCoreV1SecretEnvSource {
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1SecretEnvSource
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecretEnvSource
     */
    optional?: boolean;
}
/**
 * SecretKeySelector selects a key of a Secret.
 * @export
 * @interface IoK8sApiCoreV1SecretKeySelector
 */
export interface IoK8sApiCoreV1SecretKeySelector {
    /**
     * The key of the secret to select from.  Must be a valid secret key.
     * @type {string}
     * @memberof IoK8sApiCoreV1SecretKeySelector
     */
    key?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1SecretKeySelector
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecretKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a secret into a projected volume.  The contents of the target Secret\'s Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 * @export
 * @interface IoK8sApiCoreV1SecretProjection
 */
export interface IoK8sApiCoreV1SecretProjection {
    /**
     * 
     * @type {Array<IoK8sApiCoreV1KeyToPath>}
     * @memberof IoK8sApiCoreV1SecretProjection
     */
    items?: Array<IoK8sApiCoreV1KeyToPath>;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1SecretProjection
     */
    localObjectReference?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecretProjection
     */
    optional?: boolean;
}
/**
 * Adapts a Secret into a volume.  The contents of the target Secret\'s Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 * @export
 * @interface IoK8sApiCoreV1SecretVolumeSource
 */
export interface IoK8sApiCoreV1SecretVolumeSource {
    /**
     * 
     * @type {number}
     * @memberof IoK8sApiCoreV1SecretVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1KeyToPath>}
     * @memberof IoK8sApiCoreV1SecretVolumeSource
     */
    items?: Array<IoK8sApiCoreV1KeyToPath>;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecretVolumeSource
     */
    optional?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SecretVolumeSource
     */
    secretName?: string;
}
/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 * @export
 * @interface IoK8sApiCoreV1SecurityContext
 */
export interface IoK8sApiCoreV1SecurityContext {
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    allowPrivilegeEscalation?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1Capabilities}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    capabilities?: IoK8sApiCoreV1Capabilities;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    privileged?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    procMount?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    readOnlyRootFilesystem?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SELinuxOptions}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    seLinuxOptions?: IoK8sApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {IoK8sApiCoreV1WindowsSecurityContextOptions}
     * @memberof IoK8sApiCoreV1SecurityContext
     */
    windowsOptions?: IoK8sApiCoreV1WindowsSecurityContextOptions;
}
/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 * @export
 * @interface IoK8sApiCoreV1ServiceAccountTokenProjection
 */
export interface IoK8sApiCoreV1ServiceAccountTokenProjection {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ServiceAccountTokenProjection
     */
    audience?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1ServiceAccountTokenProjection
     */
    expirationSeconds?: string;
    /**
     * Path is the path relative to the mount point of the file to project the token into.
     * @type {string}
     * @memberof IoK8sApiCoreV1ServiceAccountTokenProjection
     */
    path?: string;
}
/**
 * Represents a StorageOS persistent volume resource.
 * @export
 * @interface IoK8sApiCoreV1StorageOSVolumeSource
 */
export interface IoK8sApiCoreV1StorageOSVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1StorageOSVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1StorageOSVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1LocalObjectReference}
     * @memberof IoK8sApiCoreV1StorageOSVolumeSource
     */
    secretRef?: IoK8sApiCoreV1LocalObjectReference;
    /**
     * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
     * @type {string}
     * @memberof IoK8sApiCoreV1StorageOSVolumeSource
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1StorageOSVolumeSource
     */
    volumeNamespace?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1Sysctl
 */
export interface IoK8sApiCoreV1Sysctl {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Sysctl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Sysctl
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1TCPSocketAction
 */
export interface IoK8sApiCoreV1TCPSocketAction {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1TCPSocketAction
     */
    host?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1IntOrString}
     * @memberof IoK8sApiCoreV1TCPSocketAction
     */
    port?: IoK8sApiCoreV1IntOrString;
}
/**
 * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.  +protobuf.options.marshal=false +protobuf.as=Timestamp +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface IoK8sApiCoreV1Time
 */
export interface IoK8sApiCoreV1Time {
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @type {number}
     * @memberof IoK8sApiCoreV1Time
     */
    nanos?: number;
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @type {string}
     * @memberof IoK8sApiCoreV1Time
     */
    seconds?: string;
}
/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 * @export
 * @interface IoK8sApiCoreV1Toleration
 */
export interface IoK8sApiCoreV1Toleration {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Toleration
     */
    effect?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Toleration
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Toleration
     */
    operator?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Toleration
     */
    tolerationSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Toleration
     */
    value?: string;
}
/**
 * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
 * @export
 * @interface IoK8sApiCoreV1TypedLocalObjectReference
 */
export interface IoK8sApiCoreV1TypedLocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1TypedLocalObjectReference
     */
    apiGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1TypedLocalObjectReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1TypedLocalObjectReference
     */
    name?: string;
}
/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 * @export
 * @interface IoK8sApiCoreV1Volume
 */
export interface IoK8sApiCoreV1Volume {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1Volume
     */
    name?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1VolumeSource}
     * @memberof IoK8sApiCoreV1Volume
     */
    volumeSource?: IoK8sApiCoreV1VolumeSource;
}
/**
 * volumeDevice describes a mapping of a raw block device within a container.
 * @export
 * @interface IoK8sApiCoreV1VolumeDevice
 */
export interface IoK8sApiCoreV1VolumeDevice {
    /**
     * devicePath is the path inside of the container that the device will be mapped to.
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeDevice
     */
    devicePath?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeDevice
     */
    name?: string;
}
/**
 * VolumeMount describes a mounting of a Volume within a container.
 * @export
 * @interface IoK8sApiCoreV1VolumeMount
 */
export interface IoK8sApiCoreV1VolumeMount {
    /**
     * Path within the container at which the volume should be mounted.  Must not contain \':\'.
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    mountPath?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    mountPropagation?: string;
    /**
     * This must match the Name of a Volume.
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    subPath?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VolumeMount
     */
    subPathExpr?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1VolumeProjection
 */
export interface IoK8sApiCoreV1VolumeProjection {
    /**
     * 
     * @type {IoK8sApiCoreV1ConfigMapProjection}
     * @memberof IoK8sApiCoreV1VolumeProjection
     */
    configMap?: IoK8sApiCoreV1ConfigMapProjection;
    /**
     * 
     * @type {IoK8sApiCoreV1DownwardAPIProjection}
     * @memberof IoK8sApiCoreV1VolumeProjection
     */
    downwardAPI?: IoK8sApiCoreV1DownwardAPIProjection;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretProjection}
     * @memberof IoK8sApiCoreV1VolumeProjection
     */
    secret?: IoK8sApiCoreV1SecretProjection;
    /**
     * 
     * @type {IoK8sApiCoreV1ServiceAccountTokenProjection}
     * @memberof IoK8sApiCoreV1VolumeProjection
     */
    serviceAccountToken?: IoK8sApiCoreV1ServiceAccountTokenProjection;
}
/**
 * Represents the source of a volume to mount. Only one of its members may be specified.
 * @export
 * @interface IoK8sApiCoreV1VolumeSource
 */
export interface IoK8sApiCoreV1VolumeSource {
    /**
     * 
     * @type {IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    awsElasticBlockStore?: IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1AzureDiskVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    azureDisk?: IoK8sApiCoreV1AzureDiskVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1AzureFileVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    azureFile?: IoK8sApiCoreV1AzureFileVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1CephFSVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    cephfs?: IoK8sApiCoreV1CephFSVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1CinderVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    cinder?: IoK8sApiCoreV1CinderVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1ConfigMapVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    configMap?: IoK8sApiCoreV1ConfigMapVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1CSIVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    csi?: IoK8sApiCoreV1CSIVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1DownwardAPIVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    downwardAPI?: IoK8sApiCoreV1DownwardAPIVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1EmptyDirVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    emptyDir?: IoK8sApiCoreV1EmptyDirVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1FCVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    fc?: IoK8sApiCoreV1FCVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1FlexVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    flexVolume?: IoK8sApiCoreV1FlexVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1FlockerVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    flocker?: IoK8sApiCoreV1FlockerVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1GCEPersistentDiskVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    gcePersistentDisk?: IoK8sApiCoreV1GCEPersistentDiskVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1GitRepoVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    gitRepo?: IoK8sApiCoreV1GitRepoVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1GlusterfsVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    glusterfs?: IoK8sApiCoreV1GlusterfsVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1HostPathVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    hostPath?: IoK8sApiCoreV1HostPathVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1ISCSIVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    iscsi?: IoK8sApiCoreV1ISCSIVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1NFSVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    nfs?: IoK8sApiCoreV1NFSVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1PersistentVolumeClaimVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    persistentVolumeClaim?: IoK8sApiCoreV1PersistentVolumeClaimVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1PhotonPersistentDiskVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    photonPersistentDisk?: IoK8sApiCoreV1PhotonPersistentDiskVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1PortworxVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    portworxVolume?: IoK8sApiCoreV1PortworxVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1ProjectedVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    projected?: IoK8sApiCoreV1ProjectedVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1QuobyteVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    quobyte?: IoK8sApiCoreV1QuobyteVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1RBDVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    rbd?: IoK8sApiCoreV1RBDVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1ScaleIOVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    scaleIO?: IoK8sApiCoreV1ScaleIOVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    secret?: IoK8sApiCoreV1SecretVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1StorageOSVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    storageos?: IoK8sApiCoreV1StorageOSVolumeSource;
    /**
     * 
     * @type {IoK8sApiCoreV1VsphereVirtualDiskVolumeSource}
     * @memberof IoK8sApiCoreV1VolumeSource
     */
    vsphereVolume?: IoK8sApiCoreV1VsphereVirtualDiskVolumeSource;
}
/**
 * Represents a vSphere volume resource.
 * @export
 * @interface IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
 */
export interface IoK8sApiCoreV1VsphereVirtualDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyID?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
     */
    volumePath?: string;
}
/**
 * 
 * @export
 * @interface IoK8sApiCoreV1WeightedPodAffinityTerm
 */
export interface IoK8sApiCoreV1WeightedPodAffinityTerm {
    /**
     * 
     * @type {IoK8sApiCoreV1PodAffinityTerm}
     * @memberof IoK8sApiCoreV1WeightedPodAffinityTerm
     */
    podAffinityTerm?: IoK8sApiCoreV1PodAffinityTerm;
    /**
     * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
     * @type {number}
     * @memberof IoK8sApiCoreV1WeightedPodAffinityTerm
     */
    weight?: number;
}
/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 * @export
 * @interface IoK8sApiCoreV1WindowsSecurityContextOptions
 */
export interface IoK8sApiCoreV1WindowsSecurityContextOptions {
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpec?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpecName?: string;
    /**
     * 
     * @type {string}
     * @memberof IoK8sApiCoreV1WindowsSecurityContextOptions
     */
    runAsUserName?: string;
}
/**
 * +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {boolean}
     * @memberof Item
     */
    boolVal?: boolean;
    /**
     * 
     * @type {Array<ItemValue>}
     * @memberof Item
     */
    listVal?: Array<ItemValue>;
    /**
     * 
     * @type {{ [key: string]: ItemValue; }}
     * @memberof Item
     */
    mapVal?: { [key: string]: ItemValue; };
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    numVal?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    strVal?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ItemValue
 */
export interface ItemValue {
    /**
     * 
     * @type {boolean}
     * @memberof ItemValue
     */
    boolVal?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemValue
     */
    listVal?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ItemValue
     */
    mapVal?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ItemValue
     */
    numVal?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemValue
     */
    strVal?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemValue
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    scope?: string;
    /**
     * The URL. May contain \"${metadata.namespace}\" and \"${metadata.name}\".
     * @type {string}
     * @memberof Link
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    podName?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Metadata
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Metadata
     */
    labels?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface MetricLabel
 */
export interface MetricLabel {
    /**
     * 
     * @type {string}
     * @memberof MetricLabel
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricLabel
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * 
     * @type {Array<Prometheus>}
     * @memberof Metrics
     */
    prometheus?: Array<Prometheus>;
}
/**
 * 
 * @export
 * @interface NodeStatus
 */
export interface NodeStatus {
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    boundaryID?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeStatus
     */
    children?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof NodeStatus
     */
    daemoned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    displayName?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof NodeStatus
     */
    finishedAt?: IoK8sApiCoreV1Time;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    id?: string;
    /**
     * 
     * @type {Inputs}
     * @memberof NodeStatus
     */
    inputs?: Inputs;
    /**
     * A human readable message indicating details about why the node is in this condition.
     * @type {string}
     * @memberof NodeStatus
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    name?: string;
    /**
     * OutboundNodes tracks the node IDs which are considered \"outbound\" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as \"outbound\". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.  In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the \"outbound\" node. In the case of DAGs, outbound nodes are the \"target\" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children.
     * @type {Array<string>}
     * @memberof NodeStatus
     */
    outboundNodes?: Array<string>;
    /**
     * 
     * @type {Outputs}
     * @memberof NodeStatus
     */
    outputs?: Outputs;
    /**
     * Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine.
     * @type {string}
     * @memberof NodeStatus
     */
    phase?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    podIP?: string;
    /**
     * ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
     * @type {{ [key: string]: string; }}
     * @memberof NodeStatus
     */
    resourcesDuration?: { [key: string]: string; };
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof NodeStatus
     */
    startedAt?: IoK8sApiCoreV1Time;
    /**
     * StoredTemplateID is the ID of stored template. DEPRECATED: This value is not used anymore.
     * @type {string}
     * @memberof NodeStatus
     */
    storedTemplateID?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    templateName?: string;
    /**
     * 
     * @type {TemplateRef}
     * @memberof NodeStatus
     */
    templateRef?: TemplateRef;
    /**
     * TemplateScope is the template scope in which the template of this node was retrieved.
     * @type {string}
     * @memberof NodeStatus
     */
    templateScope?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeStatus
     */
    type?: string;
    /**
     * WorkflowTemplateName is the WorkflowTemplate resource name on which the resolved template of this node is retrieved. DEPRECATED: This value is not used anymore.
     * @type {string}
     * @memberof NodeStatus
     */
    workflowTemplateName?: string;
}
/**
 * 
 * @export
 * @interface OSSArtifact
 */
export interface OSSArtifact {
    /**
     * 
     * @type {string}
     * @memberof OSSArtifact
     */
    key?: string;
    /**
     * 
     * @type {OSSBucket}
     * @memberof OSSArtifact
     */
    oSSBucket?: OSSBucket;
}
/**
 * 
 * @export
 * @interface OSSBucket
 */
export interface OSSBucket {
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof OSSBucket
     */
    accessKeySecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {string}
     * @memberof OSSBucket
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof OSSBucket
     */
    endpoint?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof OSSBucket
     */
    secretKeySecret?: IoK8sApiCoreV1SecretKeySelector;
}
/**
 * 
 * @export
 * @interface Outputs
 */
export interface Outputs {
    /**
     * 
     * @type {Array<Artifact>}
     * @memberof Outputs
     */
    artifacts?: Array<Artifact>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Outputs
     */
    parameters?: Array<Parameter>;
    /**
     * 
     * @type {string}
     * @memberof Outputs
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    _default?: string;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    globalName?: string;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    value?: string;
    /**
     * 
     * @type {ValueFrom}
     * @memberof Parameter
     */
    valueFrom?: ValueFrom;
}
/**
 * 
 * @export
 * @interface PodGC
 */
export interface PodGC {
    /**
     * 
     * @type {string}
     * @memberof PodGC
     */
    strategy?: string;
}
/**
 * 
 * @export
 * @interface Prometheus
 */
export interface Prometheus {
    /**
     * 
     * @type {Counter}
     * @memberof Prometheus
     */
    counter?: Counter;
    /**
     * 
     * @type {Gauge}
     * @memberof Prometheus
     */
    gauge?: Gauge;
    /**
     * 
     * @type {string}
     * @memberof Prometheus
     */
    help?: string;
    /**
     * 
     * @type {Histogram}
     * @memberof Prometheus
     */
    histogram?: Histogram;
    /**
     * 
     * @type {Array<MetricLabel>}
     * @memberof Prometheus
     */
    labels?: Array<MetricLabel>;
    /**
     * 
     * @type {string}
     * @memberof Prometheus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Prometheus
     */
    when?: string;
}
/**
 * 
 * @export
 * @interface RawArtifact
 */
export interface RawArtifact {
    /**
     * 
     * @type {string}
     * @memberof RawArtifact
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface ResourceTemplate
 */
export interface ResourceTemplate {
    /**
     * 
     * @type {string}
     * @memberof ResourceTemplate
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceTemplate
     */
    failureCondition?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceTemplate
     */
    manifest?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceTemplate
     */
    mergeStrategy?: string;
    /**
     * SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource.
     * @type {boolean}
     * @memberof ResourceTemplate
     */
    setOwnerReference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourceTemplate
     */
    successCondition?: string;
}
/**
 * 
 * @export
 * @interface RetryStrategy
 */
export interface RetryStrategy {
    /**
     * 
     * @type {Backoff}
     * @memberof RetryStrategy
     */
    backoff?: Backoff;
    /**
     * 
     * @type {number}
     * @memberof RetryStrategy
     */
    limit?: number;
    /**
     * 
     * @type {string}
     * @memberof RetryStrategy
     */
    retryPolicy?: string;
}
/**
 * 
 * @export
 * @interface S3Artifact
 */
export interface S3Artifact {
    /**
     * 
     * @type {string}
     * @memberof S3Artifact
     */
    key?: string;
    /**
     * 
     * @type {S3Bucket}
     * @memberof S3Artifact
     */
    s3Bucket?: S3Bucket;
}
/**
 * 
 * @export
 * @interface S3Bucket
 */
export interface S3Bucket {
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof S3Bucket
     */
    accessKeySecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * 
     * @type {string}
     * @memberof S3Bucket
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof S3Bucket
     */
    endpoint?: string;
    /**
     * 
     * @type {boolean}
     * @memberof S3Bucket
     */
    insecure?: boolean;
    /**
     * 
     * @type {string}
     * @memberof S3Bucket
     */
    region?: string;
    /**
     * RoleARN is the Amazon Resource Name (ARN) of the role to assume.
     * @type {string}
     * @memberof S3Bucket
     */
    roleARN?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1SecretKeySelector}
     * @memberof S3Bucket
     */
    secretKeySecret?: IoK8sApiCoreV1SecretKeySelector;
    /**
     * UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
     * @type {boolean}
     * @memberof S3Bucket
     */
    useSDKCreds?: boolean;
}
/**
 * 
 * @export
 * @interface ScriptTemplate
 */
export interface ScriptTemplate {
    /**
     * 
     * @type {IoK8sApiCoreV1Container}
     * @memberof ScriptTemplate
     */
    container?: IoK8sApiCoreV1Container;
    /**
     * 
     * @type {string}
     * @memberof ScriptTemplate
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface Sequence
 */
export interface Sequence {
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    count?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    format?: string;
    /**
     * 
     * @type {string}
     * @memberof Sequence
     */
    start?: string;
}
/**
 * 
 * @export
 * @interface SuspendTemplate
 */
export interface SuspendTemplate {
    /**
     * 
     * @type {string}
     * @memberof SuspendTemplate
     */
    duration?: string;
}
/**
 * 
 * @export
 * @interface TTLStrategy
 */
export interface TTLStrategy {
    /**
     * 
     * @type {number}
     * @memberof TTLStrategy
     */
    secondsAfterCompletion?: number;
    /**
     * 
     * @type {number}
     * @memberof TTLStrategy
     */
    secondsAfterFailure?: number;
    /**
     * 
     * @type {number}
     * @memberof TTLStrategy
     */
    secondsAfterSuccess?: number;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
     * @type {string}
     * @memberof Template
     */
    activeDeadlineSeconds?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Affinity}
     * @memberof Template
     */
    affinity?: IoK8sApiCoreV1Affinity;
    /**
     * 
     * @type {ArtifactLocation}
     * @memberof Template
     */
    archiveLocation?: ArtifactLocation;
    /**
     * 
     * @type {Arguments}
     * @memberof Template
     */
    arguments?: Arguments;
    /**
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
     * @type {boolean}
     * @memberof Template
     */
    automountServiceAccountToken?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1Container}
     * @memberof Template
     */
    container?: IoK8sApiCoreV1Container;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    daemon?: boolean;
    /**
     * 
     * @type {DAGTemplate}
     * @memberof Template
     */
    dag?: DAGTemplate;
    /**
     * 
     * @type {ExecutorConfig}
     * @memberof Template
     */
    executor?: ExecutorConfig;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1HostAlias>}
     * @memberof Template
     */
    hostAliases?: Array<IoK8sApiCoreV1HostAlias>;
    /**
     * 
     * @type {Array<UserContainer>}
     * @memberof Template
     */
    initContainers?: Array<UserContainer>;
    /**
     * 
     * @type {Inputs}
     * @memberof Template
     */
    inputs?: Inputs;
    /**
     * 
     * @type {Metadata}
     * @memberof Template
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Metrics}
     * @memberof Template
     */
    metrics?: Metrics;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    name?: string;
    /**
     * NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
     * @type {{ [key: string]: string; }}
     * @memberof Template
     */
    nodeSelector?: { [key: string]: string; };
    /**
     * 
     * @type {Outputs}
     * @memberof Template
     */
    outputs?: Outputs;
    /**
     * Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
     * @type {number}
     * @memberof Template
     */
    parallelism?: number;
    /**
     * PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
     * @type {string}
     * @memberof Template
     */
    podSpecPatch?: string;
    /**
     * Priority to apply to workflow pods.
     * @type {number}
     * @memberof Template
     */
    priority?: number;
    /**
     * PriorityClassName to apply to workflow pods.
     * @type {string}
     * @memberof Template
     */
    priorityClassName?: string;
    /**
     * 
     * @type {ResourceTemplate}
     * @memberof Template
     */
    resource?: ResourceTemplate;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    resubmitPendingPods?: boolean;
    /**
     * 
     * @type {RetryStrategy}
     * @memberof Template
     */
    retryStrategy?: RetryStrategy;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    schedulerName?: string;
    /**
     * 
     * @type {ScriptTemplate}
     * @memberof Template
     */
    script?: ScriptTemplate;
    /**
     * 
     * @type {IoK8sApiCoreV1PodSecurityContext}
     * @memberof Template
     */
    securityContext?: IoK8sApiCoreV1PodSecurityContext;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    serviceAccountName?: string;
    /**
     * 
     * @type {Array<UserContainer>}
     * @memberof Template
     */
    sidecars?: Array<UserContainer>;
    /**
     * 
     * @type {Array<Array<WorkflowStep>>}
     * @memberof Template
     */
    steps?: Array<Array<WorkflowStep>>;
    /**
     * 
     * @type {SuspendTemplate}
     * @memberof Template
     */
    suspend?: SuspendTemplate;
    /**
     * Template is the name of the template which is used as the base of this template. DEPRECATED: This field is not used.
     * @type {string}
     * @memberof Template
     */
    template?: string;
    /**
     * 
     * @type {TemplateRef}
     * @memberof Template
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1Toleration>}
     * @memberof Template
     */
    tolerations?: Array<IoK8sApiCoreV1Toleration>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1Volume>}
     * @memberof Template
     */
    volumes?: Array<IoK8sApiCoreV1Volume>;
}
/**
 * TemplateRef is a reference of template resource.
 * @export
 * @interface TemplateRef
 */
export interface TemplateRef {
    /**
     * Name is the resource name of the template.
     * @type {string}
     * @memberof TemplateRef
     */
    name?: string;
    /**
     * RuntimeResolution skips validation at creation time. By enabling this option, you can create the referred workflow template before the actual runtime.
     * @type {boolean}
     * @memberof TemplateRef
     */
    runtimeResolution?: boolean;
    /**
     * Template is the name of referred template in the resource.
     * @type {string}
     * @memberof TemplateRef
     */
    template?: string;
}
/**
 * UserContainer is a container specified by a user.
 * @export
 * @interface UserContainer
 */
export interface UserContainer {
    /**
     * 
     * @type {IoK8sApiCoreV1Container}
     * @memberof UserContainer
     */
    container?: IoK8sApiCoreV1Container;
    /**
     * 
     * @type {boolean}
     * @memberof UserContainer
     */
    mirrorVolumeMounts?: boolean;
}
/**
 * 
 * @export
 * @interface ValueFrom
 */
export interface ValueFrom {
    /**
     * 
     * @type {string}
     * @memberof ValueFrom
     */
    _default?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueFrom
     */
    jqFilter?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueFrom
     */
    jsonPath?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueFrom
     */
    parameter?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueFrom
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectMeta}
     * @memberof Workflow
     */
    metadata?: IoK8sApiCoreV1ObjectMeta;
    /**
     * 
     * @type {WorkflowSpec}
     * @memberof Workflow
     */
    spec?: WorkflowSpec;
    /**
     * 
     * @type {WorkflowStatus}
     * @memberof Workflow
     */
    status?: WorkflowStatus;
}
/**
 * 
 * @export
 * @interface WorkflowCondition
 */
export interface WorkflowCondition {
    /**
     * 
     * @type {string}
     * @memberof WorkflowCondition
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCondition
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface WorkflowCreateRequest
 */
export interface WorkflowCreateRequest {
    /**
     * 
     * @type {IoK8sApiCoreV1CreateOptions}
     * @memberof WorkflowCreateRequest
     */
    createOptions?: IoK8sApiCoreV1CreateOptions;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCreateRequest
     */
    instanceID?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCreateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowCreateRequest
     */
    serverDryRun?: boolean;
    /**
     * 
     * @type {Workflow}
     * @memberof WorkflowCreateRequest
     */
    workflow?: Workflow;
}
/**
 * 
 * @export
 * @interface WorkflowLintRequest
 */
export interface WorkflowLintRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowLintRequest
     */
    namespace?: string;
    /**
     * 
     * @type {Workflow}
     * @memberof WorkflowLintRequest
     */
    workflow?: Workflow;
}
/**
 * 
 * @export
 * @interface WorkflowList
 */
export interface WorkflowList {
    /**
     * 
     * @type {Array<Workflow>}
     * @memberof WorkflowList
     */
    items?: Array<Workflow>;
    /**
     * 
     * @type {IoK8sApiCoreV1ListMeta}
     * @memberof WorkflowList
     */
    metadata?: IoK8sApiCoreV1ListMeta;
}
/**
 * 
 * @export
 * @interface WorkflowResubmitRequest
 */
export interface WorkflowResubmitRequest {
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowResubmitRequest
     */
    memoized?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResubmitRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResubmitRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface WorkflowResumeRequest
 */
export interface WorkflowResumeRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowResumeRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResumeRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResumeRequest
     */
    nodeFieldSelector?: string;
}
/**
 * 
 * @export
 * @interface WorkflowRetryRequest
 */
export interface WorkflowRetryRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowRetryRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRetryRequest
     */
    namespace?: string;
}
/**
 * WorkflowSpec is the specification of a Workflow.
 * @export
 * @interface WorkflowSpec
 */
export interface WorkflowSpec {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSpec
     */
    activeDeadlineSeconds?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1Affinity}
     * @memberof WorkflowSpec
     */
    affinity?: IoK8sApiCoreV1Affinity;
    /**
     * 
     * @type {Arguments}
     * @memberof WorkflowSpec
     */
    arguments?: Arguments;
    /**
     * 
     * @type {ArtifactRepositoryRef}
     * @memberof WorkflowSpec
     */
    artifactRepositoryRef?: ArtifactRepositoryRef;
    /**
     * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
     * @type {boolean}
     * @memberof WorkflowSpec
     */
    automountServiceAccountToken?: boolean;
    /**
     * 
     * @type {IoK8sApiCoreV1PodDNSConfig}
     * @memberof WorkflowSpec
     */
    dnsConfig?: IoK8sApiCoreV1PodDNSConfig;
    /**
     * Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are \'ClusterFirstWithHostNet\', \'ClusterFirst\', \'Default\' or \'None\'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to \'ClusterFirstWithHostNet\'.
     * @type {string}
     * @memberof WorkflowSpec
     */
    dnsPolicy?: string;
    /**
     * Entrypoint is a template reference to the starting point of the 
     * @type {string}
     * @memberof WorkflowSpec
     */
    entrypoint?: string;
    /**
     * 
     * @type {ExecutorConfig}
     * @memberof WorkflowSpec
     */
    executor?: ExecutorConfig;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1HostAlias>}
     * @memberof WorkflowSpec
     */
    hostAliases?: Array<IoK8sApiCoreV1HostAlias>;
    /**
     * Host networking requested for this workflow pod. Default to false.
     * @type {boolean}
     * @memberof WorkflowSpec
     */
    hostNetwork?: boolean;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1LocalObjectReference>}
     * @memberof WorkflowSpec
     */
    imagePullSecrets?: Array<IoK8sApiCoreV1LocalObjectReference>;
    /**
     * 
     * @type {Metrics}
     * @memberof WorkflowSpec
     */
    metrics?: Metrics;
    /**
     * NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
     * @type {{ [key: string]: string; }}
     * @memberof WorkflowSpec
     */
    nodeSelector?: { [key: string]: string; };
    /**
     * OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary 
     * @type {string}
     * @memberof WorkflowSpec
     */
    onExit?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowSpec
     */
    parallelism?: number;
    /**
     * 
     * @type {IoK8sApiCoreV1PodDisruptionBudgetSpec}
     * @memberof WorkflowSpec
     */
    podDisruptionBudget?: IoK8sApiCoreV1PodDisruptionBudgetSpec;
    /**
     * 
     * @type {PodGC}
     * @memberof WorkflowSpec
     */
    podGC?: PodGC;
    /**
     * Priority to apply to workflow pods.
     * @type {number}
     * @memberof WorkflowSpec
     */
    podPriority?: number;
    /**
     * PriorityClassName to apply to workflow pods.
     * @type {string}
     * @memberof WorkflowSpec
     */
    podPriorityClassName?: string;
    /**
     * PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
     * @type {string}
     * @memberof WorkflowSpec
     */
    podSpecPatch?: string;
    /**
     * Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
     * @type {number}
     * @memberof WorkflowSpec
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSpec
     */
    schedulerName?: string;
    /**
     * 
     * @type {IoK8sApiCoreV1PodSecurityContext}
     * @memberof WorkflowSpec
     */
    securityContext?: IoK8sApiCoreV1PodSecurityContext;
    /**
     * ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
     * @type {string}
     * @memberof WorkflowSpec
     */
    serviceAccountName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSpec
     */
    shutdown?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowSpec
     */
    suspend?: boolean;
    /**
     * 
     * @type {Array<Template>}
     * @memberof WorkflowSpec
     */
    templates?: Array<Template>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1Toleration>}
     * @memberof WorkflowSpec
     */
    tolerations?: Array<IoK8sApiCoreV1Toleration>;
    /**
     * TTLSecondsAfterFinished limits the lifetime of a Workflow that has finished execution (Succeeded, Failed, Error). If this field is set, once the Workflow finishes, it will be deleted after ttlSecondsAfterFinished expires. If this field is unset, ttlSecondsAfterFinished will not expire. If this field is set to zero, ttlSecondsAfterFinished expires immediately after the Workflow finishes. DEPRECATED: Use TTLStrategy.SecondsAfterCompletion instead.
     * @type {number}
     * @memberof WorkflowSpec
     */
    ttlSecondsAfterFinished?: number;
    /**
     * 
     * @type {TTLStrategy}
     * @memberof WorkflowSpec
     */
    ttlStrategy?: TTLStrategy;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1PersistentVolumeClaim>}
     * @memberof WorkflowSpec
     */
    volumeClaimTemplates?: Array<IoK8sApiCoreV1PersistentVolumeClaim>;
    /**
     * 
     * @type {Array<IoK8sApiCoreV1Volume>}
     * @memberof WorkflowSpec
     */
    volumes?: Array<IoK8sApiCoreV1Volume>;
}
/**
 * 
 * @export
 * @interface WorkflowStatus
 */
export interface WorkflowStatus {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStatus
     */
    compressedNodes?: string;
    /**
     * 
     * @type {Array<WorkflowCondition>}
     * @memberof WorkflowStatus
     */
    conditions?: Array<WorkflowCondition>;
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof WorkflowStatus
     */
    finishedAt?: IoK8sApiCoreV1Time;
    /**
     * A human readable message indicating details about why the workflow is in this condition.
     * @type {string}
     * @memberof WorkflowStatus
     */
    message?: string;
    /**
     * Nodes is a mapping between a node ID and the node\'s status.
     * @type {{ [key: string]: NodeStatus; }}
     * @memberof WorkflowStatus
     */
    nodes?: { [key: string]: NodeStatus; };
    /**
     * Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty. This will actually be populated with a hash of the offloaded data.
     * @type {string}
     * @memberof WorkflowStatus
     */
    offloadNodeStatusVersion?: string;
    /**
     * 
     * @type {Outputs}
     * @memberof WorkflowStatus
     */
    outputs?: Outputs;
    /**
     * PersistentVolumeClaims tracks all PVCs that were created as part of the  The contents of this list are drained at the end of the workflow.
     * @type {Array<IoK8sApiCoreV1Volume>}
     * @memberof WorkflowStatus
     */
    persistentVolumeClaims?: Array<IoK8sApiCoreV1Volume>;
    /**
     * Phase a simple, high-level summary of where the workflow is in its lifecycle.
     * @type {string}
     * @memberof WorkflowStatus
     */
    phase?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkflowStatus
     */
    resourcesDuration?: { [key: string]: string; };
    /**
     * 
     * @type {IoK8sApiCoreV1Time}
     * @memberof WorkflowStatus
     */
    startedAt?: IoK8sApiCoreV1Time;
    /**
     * StoredTemplates is a mapping between a template ref and the node\'s status.
     * @type {{ [key: string]: Template; }}
     * @memberof WorkflowStatus
     */
    storedTemplates?: { [key: string]: Template; };
}
/**
 * 
 * @export
 * @interface WorkflowStep
 */
export interface WorkflowStep {
    /**
     * 
     * @type {Arguments}
     * @memberof WorkflowStep
     */
    arguments?: Arguments;
    /**
     * 
     * @type {ContinueOn}
     * @memberof WorkflowStep
     */
    continueOn?: ContinueOn;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    name?: string;
    /**
     * OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template.
     * @type {string}
     * @memberof WorkflowStep
     */
    onExit?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    template?: string;
    /**
     * 
     * @type {TemplateRef}
     * @memberof WorkflowStep
     */
    templateRef?: TemplateRef;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStep
     */
    when?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof WorkflowStep
     */
    withItems?: Array<Item>;
    /**
     * WithParam expands a step into multiple parallel steps from the value in the parameter, which is expected to be a JSON list.
     * @type {string}
     * @memberof WorkflowStep
     */
    withParam?: string;
    /**
     * 
     * @type {Sequence}
     * @memberof WorkflowStep
     */
    withSequence?: Sequence;
}
/**
 * 
 * @export
 * @interface WorkflowStopRequest
 */
export interface WorkflowStopRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    nodeFieldSelector?: string;
}
/**
 * 
 * @export
 * @interface WorkflowSuspendRequest
 */
export interface WorkflowSuspendRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSuspendRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSuspendRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface WorkflowTemplate
 */
export interface WorkflowTemplate {
    /**
     * 
     * @type {IoK8sApiCoreV1ObjectMeta}
     * @memberof WorkflowTemplate
     */
    metadata?: IoK8sApiCoreV1ObjectMeta;
    /**
     * 
     * @type {WorkflowTemplateSpec}
     * @memberof WorkflowTemplate
     */
    spec?: WorkflowTemplateSpec;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateCreateRequest
 */
export interface WorkflowTemplateCreateRequest {
    /**
     * 
     * @type {IoK8sApiCoreV1CreateOptions}
     * @memberof WorkflowTemplateCreateRequest
     */
    createOptions?: IoK8sApiCoreV1CreateOptions;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateCreateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {WorkflowTemplate}
     * @memberof WorkflowTemplateCreateRequest
     */
    template?: WorkflowTemplate;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateLintRequest
 */
export interface WorkflowTemplateLintRequest {
    /**
     * 
     * @type {IoK8sApiCoreV1CreateOptions}
     * @memberof WorkflowTemplateLintRequest
     */
    createOptions?: IoK8sApiCoreV1CreateOptions;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateLintRequest
     */
    namespace?: string;
    /**
     * 
     * @type {WorkflowTemplate}
     * @memberof WorkflowTemplateLintRequest
     */
    template?: WorkflowTemplate;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateList
 */
export interface WorkflowTemplateList {
    /**
     * 
     * @type {Array<WorkflowTemplate>}
     * @memberof WorkflowTemplateList
     */
    items?: Array<WorkflowTemplate>;
    /**
     * 
     * @type {IoK8sApiCoreV1ListMeta}
     * @memberof WorkflowTemplateList
     */
    metadata?: IoK8sApiCoreV1ListMeta;
}
/**
 * WorkflowTemplateSpec is a spec of WorkflowTemplate.
 * @export
 * @interface WorkflowTemplateSpec
 */
export interface WorkflowTemplateSpec {
    /**
     * 
     * @type {WorkflowSpec}
     * @memberof WorkflowTemplateSpec
     */
    workflowSpec?: WorkflowSpec;
}
/**
 * 
 * @export
 * @interface WorkflowTemplateUpdateRequest
 */
export interface WorkflowTemplateUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTemplateUpdateRequest
     */
    namespace?: string;
    /**
     * 
     * @type {WorkflowTemplate}
     * @memberof WorkflowTemplateUpdateRequest
     */
    template?: WorkflowTemplate;
}
/**
 * 
 * @export
 * @interface WorkflowTerminateRequest
 */
export interface WorkflowTerminateRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowTerminateRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowTerminateRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface WorkflowWatchEvent
 */
export interface WorkflowWatchEvent {
    /**
     * 
     * @type {Workflow}
     * @memberof WorkflowWatchEvent
     */
    object?: Workflow;
    /**
     * 
     * @type {string}
     * @memberof WorkflowWatchEvent
     */
    type?: string;
}

/**
 * ArchivedWorkflowServiceApi - axios parameter creator
 * @export
 */
export const ArchivedWorkflowServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArchivedWorkflow(uid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling deleteArchivedWorkflow.');
            }
            const localVarPath = `/api/v1/archived-workflows/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedWorkflow(uid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getArchivedWorkflow.');
            }
            const localVarPath = `/api/v1/archived-workflows/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedWorkflows(listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/archived-workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (listOptionsLabelSelector !== undefined) {
                localVarQueryParameter['listOptions.labelSelector'] = listOptionsLabelSelector;
            }

            if (listOptionsFieldSelector !== undefined) {
                localVarQueryParameter['listOptions.fieldSelector'] = listOptionsFieldSelector;
            }

            if (listOptionsWatch !== undefined) {
                localVarQueryParameter['listOptions.watch'] = listOptionsWatch;
            }

            if (listOptionsAllowWatchBookmarks !== undefined) {
                localVarQueryParameter['listOptions.allowWatchBookmarks'] = listOptionsAllowWatchBookmarks;
            }

            if (listOptionsResourceVersion !== undefined) {
                localVarQueryParameter['listOptions.resourceVersion'] = listOptionsResourceVersion;
            }

            if (listOptionsTimeoutSeconds !== undefined) {
                localVarQueryParameter['listOptions.timeoutSeconds'] = listOptionsTimeoutSeconds;
            }

            if (listOptionsLimit !== undefined) {
                localVarQueryParameter['listOptions.limit'] = listOptionsLimit;
            }

            if (listOptionsContinue !== undefined) {
                localVarQueryParameter['listOptions.continue'] = listOptionsContinue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArchivedWorkflowServiceApi - functional programming interface
 * @export
 */
export const ArchivedWorkflowServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArchivedWorkflow(uid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ArchivedWorkflowServiceApiAxiosParamCreator(configuration).deleteArchivedWorkflow(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedWorkflow(uid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = ArchivedWorkflowServiceApiAxiosParamCreator(configuration).getArchivedWorkflow(uid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedWorkflows(listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowList> {
            const localVarAxiosArgs = ArchivedWorkflowServiceApiAxiosParamCreator(configuration).listArchivedWorkflows(listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArchivedWorkflowServiceApi - factory interface
 * @export
 */
export const ArchivedWorkflowServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArchivedWorkflow(uid: string, options?: any): AxiosPromise<object> {
            return ArchivedWorkflowServiceApiFp(configuration).deleteArchivedWorkflow(uid, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedWorkflow(uid: string, options?: any): AxiosPromise<Workflow> {
            return ArchivedWorkflowServiceApiFp(configuration).getArchivedWorkflow(uid, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedWorkflows(listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): AxiosPromise<WorkflowList> {
            return ArchivedWorkflowServiceApiFp(configuration).listArchivedWorkflows(listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(axios, basePath);
        },
    };
};

/**
 * ArchivedWorkflowServiceApi - object-oriented interface
 * @export
 * @class ArchivedWorkflowServiceApi
 * @extends {BaseAPI}
 */
export class ArchivedWorkflowServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchivedWorkflowServiceApi
     */
    public deleteArchivedWorkflow(uid: string, options?: any) {
        return ArchivedWorkflowServiceApiFp(this.configuration).deleteArchivedWorkflow(uid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchivedWorkflowServiceApi
     */
    public getArchivedWorkflow(uid: string, options?: any) {
        return ArchivedWorkflowServiceApiFp(this.configuration).getArchivedWorkflow(uid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
     * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
     * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
     * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
     * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
     * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchivedWorkflowServiceApi
     */
    public listArchivedWorkflows(listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any) {
        return ArchivedWorkflowServiceApiFp(this.configuration).listArchivedWorkflows(listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(this.axios, this.basePath);
    }

}


/**
 * CronWorkflowServiceApi - axios parameter creator
 * @export
 */
export const CronWorkflowServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {CronCreateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCronWorkflow(namespace: string, body: CronCreateCronWorkflowRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createCronWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCronWorkflow.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCronWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteCronWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteCronWorkflow.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deleteOptionsGracePeriodSeconds !== undefined) {
                localVarQueryParameter['deleteOptions.gracePeriodSeconds'] = deleteOptionsGracePeriodSeconds;
            }

            if (deleteOptionsPreconditionsUid !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.uid'] = deleteOptionsPreconditionsUid;
            }

            if (deleteOptionsPreconditionsResourceVersion !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.resourceVersion'] = deleteOptionsPreconditionsResourceVersion;
            }

            if (deleteOptionsOrphanDependents !== undefined) {
                localVarQueryParameter['deleteOptions.orphanDependents'] = deleteOptionsOrphanDependents;
            }

            if (deleteOptionsPropagationPolicy !== undefined) {
                localVarQueryParameter['deleteOptions.propagationPolicy'] = deleteOptionsPropagationPolicy;
            }

            if (deleteOptionsDryRun) {
                localVarQueryParameter['deleteOptions.dryRun'] = deleteOptionsDryRun;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getCronWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getCronWorkflow.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getOptionsResourceVersion !== undefined) {
                localVarQueryParameter['getOptions.resourceVersion'] = getOptionsResourceVersion;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {CronLintCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintCronWorkflow(namespace: string, body: CronLintCronWorkflowRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling lintCronWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling lintCronWorkflow.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}/lint`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling listCronWorkflows.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (listOptionsLabelSelector !== undefined) {
                localVarQueryParameter['listOptions.labelSelector'] = listOptionsLabelSelector;
            }

            if (listOptionsFieldSelector !== undefined) {
                localVarQueryParameter['listOptions.fieldSelector'] = listOptionsFieldSelector;
            }

            if (listOptionsWatch !== undefined) {
                localVarQueryParameter['listOptions.watch'] = listOptionsWatch;
            }

            if (listOptionsAllowWatchBookmarks !== undefined) {
                localVarQueryParameter['listOptions.allowWatchBookmarks'] = listOptionsAllowWatchBookmarks;
            }

            if (listOptionsResourceVersion !== undefined) {
                localVarQueryParameter['listOptions.resourceVersion'] = listOptionsResourceVersion;
            }

            if (listOptionsTimeoutSeconds !== undefined) {
                localVarQueryParameter['listOptions.timeoutSeconds'] = listOptionsTimeoutSeconds;
            }

            if (listOptionsLimit !== undefined) {
                localVarQueryParameter['listOptions.limit'] = listOptionsLimit;
            }

            if (listOptionsContinue !== undefined) {
                localVarQueryParameter['listOptions.continue'] = listOptionsContinue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {CronUpdateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCronWorkflow(namespace: string, name: string, body: CronUpdateCronWorkflowRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateCronWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateCronWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCronWorkflow.');
            }
            const localVarPath = `/api/v1/cron-workflows/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CronWorkflowServiceApi - functional programming interface
 * @export
 */
export const CronWorkflowServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {CronCreateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCronWorkflow(namespace: string, body: CronCreateCronWorkflowRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronWorkflow> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).createCronWorkflow(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCronWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).deleteCronWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronWorkflow> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).getCronWorkflow(namespace, name, getOptionsResourceVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {CronLintCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintCronWorkflow(namespace: string, body: CronLintCronWorkflowRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronWorkflow> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).lintCronWorkflow(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronWorkflowList> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).listCronWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {CronUpdateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCronWorkflow(namespace: string, name: string, body: CronUpdateCronWorkflowRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronWorkflow> {
            const localVarAxiosArgs = CronWorkflowServiceApiAxiosParamCreator(configuration).updateCronWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CronWorkflowServiceApi - factory interface
 * @export
 */
export const CronWorkflowServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {CronCreateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCronWorkflow(namespace: string, body: CronCreateCronWorkflowRequest, options?: any): AxiosPromise<CronWorkflow> {
            return CronWorkflowServiceApiFp(configuration).createCronWorkflow(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCronWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): AxiosPromise<object> {
            return CronWorkflowServiceApiFp(configuration).deleteCronWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any): AxiosPromise<CronWorkflow> {
            return CronWorkflowServiceApiFp(configuration).getCronWorkflow(namespace, name, getOptionsResourceVersion, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {CronLintCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintCronWorkflow(namespace: string, body: CronLintCronWorkflowRequest, options?: any): AxiosPromise<CronWorkflow> {
            return CronWorkflowServiceApiFp(configuration).lintCronWorkflow(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCronWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): AxiosPromise<CronWorkflowList> {
            return CronWorkflowServiceApiFp(configuration).listCronWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {CronUpdateCronWorkflowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCronWorkflow(namespace: string, name: string, body: CronUpdateCronWorkflowRequest, options?: any): AxiosPromise<CronWorkflow> {
            return CronWorkflowServiceApiFp(configuration).updateCronWorkflow(namespace, name, body, options)(axios, basePath);
        },
    };
};

/**
 * CronWorkflowServiceApi - object-oriented interface
 * @export
 * @class CronWorkflowServiceApi
 * @extends {BaseAPI}
 */
export class CronWorkflowServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} namespace 
     * @param {CronCreateCronWorkflowRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public createCronWorkflow(namespace: string, body: CronCreateCronWorkflowRequest, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).createCronWorkflow(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
     * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
     * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
     * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
     * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
     * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public deleteCronWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).deleteCronWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public getCronWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).getCronWorkflow(namespace, name, getOptionsResourceVersion, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {CronLintCronWorkflowRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public lintCronWorkflow(namespace: string, body: CronLintCronWorkflowRequest, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).lintCronWorkflow(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
     * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
     * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
     * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
     * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
     * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public listCronWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).listCronWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {CronUpdateCronWorkflowRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronWorkflowServiceApi
     */
    public updateCronWorkflow(namespace: string, name: string, body: CronUpdateCronWorkflowRequest, options?: any) {
        return CronWorkflowServiceApiFp(this.configuration).updateCronWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

}


/**
 * InfoServiceApi - axios parameter creator
 * @export
 */
export const InfoServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoServiceApi - functional programming interface
 * @export
 */
export const InfoServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoResponse> {
            const localVarAxiosArgs = InfoServiceApiAxiosParamCreator(configuration).getInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InfoServiceApi - factory interface
 * @export
 */
export const InfoServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<InfoResponse> {
            return InfoServiceApiFp(configuration).getInfo(options)(axios, basePath);
        },
    };
};

/**
 * InfoServiceApi - object-oriented interface
 * @export
 * @class InfoServiceApi
 * @extends {BaseAPI}
 */
export class InfoServiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoServiceApi
     */
    public getInfo(options?: any) {
        return InfoServiceApiFp(this.configuration).getInfo(options)(this.axios, this.basePath);
    }

}


/**
 * WorkflowServiceApi - axios parameter creator
 * @export
 */
export const WorkflowServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(namespace: string, body: WorkflowCreateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deleteOptionsGracePeriodSeconds !== undefined) {
                localVarQueryParameter['deleteOptions.gracePeriodSeconds'] = deleteOptionsGracePeriodSeconds;
            }

            if (deleteOptionsPreconditionsUid !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.uid'] = deleteOptionsPreconditionsUid;
            }

            if (deleteOptionsPreconditionsResourceVersion !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.resourceVersion'] = deleteOptionsPreconditionsResourceVersion;
            }

            if (deleteOptionsOrphanDependents !== undefined) {
                localVarQueryParameter['deleteOptions.orphanDependents'] = deleteOptionsOrphanDependents;
            }

            if (deleteOptionsPropagationPolicy !== undefined) {
                localVarQueryParameter['deleteOptions.propagationPolicy'] = deleteOptionsPropagationPolicy;
            }

            if (deleteOptionsDryRun) {
                localVarQueryParameter['deleteOptions.dryRun'] = deleteOptionsDryRun;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;spec,status.phase\&quot;, \&quot;-status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, fields?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getOptionsResourceVersion !== undefined) {
                localVarQueryParameter['getOptions.resourceVersion'] = getOptionsResourceVersion;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflow(namespace: string, body: WorkflowLintRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling lintWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling lintWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/lint`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;items.spec,items.status.phase\&quot;, \&quot;-items.status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, fields?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling listWorkflows.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (listOptionsLabelSelector !== undefined) {
                localVarQueryParameter['listOptions.labelSelector'] = listOptionsLabelSelector;
            }

            if (listOptionsFieldSelector !== undefined) {
                localVarQueryParameter['listOptions.fieldSelector'] = listOptionsFieldSelector;
            }

            if (listOptionsWatch !== undefined) {
                localVarQueryParameter['listOptions.watch'] = listOptionsWatch;
            }

            if (listOptionsAllowWatchBookmarks !== undefined) {
                localVarQueryParameter['listOptions.allowWatchBookmarks'] = listOptionsAllowWatchBookmarks;
            }

            if (listOptionsResourceVersion !== undefined) {
                localVarQueryParameter['listOptions.resourceVersion'] = listOptionsResourceVersion;
            }

            if (listOptionsTimeoutSeconds !== undefined) {
                localVarQueryParameter['listOptions.timeoutSeconds'] = listOptionsTimeoutSeconds;
            }

            if (listOptionsLimit !== undefined) {
                localVarQueryParameter['listOptions.limit'] = listOptionsLimit;
            }

            if (listOptionsContinue !== undefined) {
                localVarQueryParameter['listOptions.continue'] = listOptionsContinue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} podName 
         * @param {string} [logOptionsContainer] The container for which to stream logs. Defaults to only container if there is one container in the pod. +optional.
         * @param {boolean} [logOptionsFollow] Follow the log stream of the pod. Defaults to false. +optional.
         * @param {boolean} [logOptionsPrevious] Return previous terminated container logs. Defaults to false. +optional.
         * @param {string} [logOptionsSinceSeconds] A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. +optional.
         * @param {string} [logOptionsSinceTimeSeconds] Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
         * @param {number} [logOptionsSinceTimeNanos] Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
         * @param {boolean} [logOptionsTimestamps] If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. +optional.
         * @param {string} [logOptionsTailLines] If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime +optional.
         * @param {string} [logOptionsLimitBytes] If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podLogs(namespace: string, name: string, podName: string, logOptionsContainer?: string, logOptionsFollow?: boolean, logOptionsPrevious?: boolean, logOptionsSinceSeconds?: string, logOptionsSinceTimeSeconds?: string, logOptionsSinceTimeNanos?: number, logOptionsTimestamps?: boolean, logOptionsTailLines?: string, logOptionsLimitBytes?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling podLogs.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling podLogs.');
            }
            // verify required parameter 'podName' is not null or undefined
            if (podName === null || podName === undefined) {
                throw new RequiredError('podName','Required parameter podName was null or undefined when calling podLogs.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/{podName}/log`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"podName"}}`, encodeURIComponent(String(podName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (logOptionsContainer !== undefined) {
                localVarQueryParameter['logOptions.container'] = logOptionsContainer;
            }

            if (logOptionsFollow !== undefined) {
                localVarQueryParameter['logOptions.follow'] = logOptionsFollow;
            }

            if (logOptionsPrevious !== undefined) {
                localVarQueryParameter['logOptions.previous'] = logOptionsPrevious;
            }

            if (logOptionsSinceSeconds !== undefined) {
                localVarQueryParameter['logOptions.sinceSeconds'] = logOptionsSinceSeconds;
            }

            if (logOptionsSinceTimeSeconds !== undefined) {
                localVarQueryParameter['logOptions.sinceTime.seconds'] = logOptionsSinceTimeSeconds;
            }

            if (logOptionsSinceTimeNanos !== undefined) {
                localVarQueryParameter['logOptions.sinceTime.nanos'] = logOptionsSinceTimeNanos;
            }

            if (logOptionsTimestamps !== undefined) {
                localVarQueryParameter['logOptions.timestamps'] = logOptionsTimestamps;
            }

            if (logOptionsTailLines !== undefined) {
                localVarQueryParameter['logOptions.tailLines'] = logOptionsTailLines;
            }

            if (logOptionsLimitBytes !== undefined) {
                localVarQueryParameter['logOptions.limitBytes'] = logOptionsLimitBytes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitWorkflow(namespace: string, name: string, body: WorkflowResubmitRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resubmitWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resubmitWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resubmitWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/resubmit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResumeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeWorkflow(namespace: string, name: string, body: WorkflowResumeRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resumeWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling resumeWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/resume`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowRetryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWorkflow(namespace: string, name: string, body: WorkflowRetryRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling retryWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling retryWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling retryWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/retry`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowStopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWorkflow(namespace: string, name: string, body: WorkflowStopRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling stopWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling stopWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/stop`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowSuspendRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendWorkflow(namespace: string, name: string, body: WorkflowSuspendRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling suspendWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling suspendWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling suspendWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/suspend`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTerminateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateWorkflow(namespace: string, name: string, body: WorkflowTerminateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling terminateWorkflow.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling terminateWorkflow.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling terminateWorkflow.');
            }
            const localVarPath = `/api/v1/workflows/{namespace}/{name}/terminate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling watchWorkflows.');
            }
            const localVarPath = `/api/v1/workflow-events/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (listOptionsLabelSelector !== undefined) {
                localVarQueryParameter['listOptions.labelSelector'] = listOptionsLabelSelector;
            }

            if (listOptionsFieldSelector !== undefined) {
                localVarQueryParameter['listOptions.fieldSelector'] = listOptionsFieldSelector;
            }

            if (listOptionsWatch !== undefined) {
                localVarQueryParameter['listOptions.watch'] = listOptionsWatch;
            }

            if (listOptionsAllowWatchBookmarks !== undefined) {
                localVarQueryParameter['listOptions.allowWatchBookmarks'] = listOptionsAllowWatchBookmarks;
            }

            if (listOptionsResourceVersion !== undefined) {
                localVarQueryParameter['listOptions.resourceVersion'] = listOptionsResourceVersion;
            }

            if (listOptionsTimeoutSeconds !== undefined) {
                localVarQueryParameter['listOptions.timeoutSeconds'] = listOptionsTimeoutSeconds;
            }

            if (listOptionsLimit !== undefined) {
                localVarQueryParameter['listOptions.limit'] = listOptionsLimit;
            }

            if (listOptionsContinue !== undefined) {
                localVarQueryParameter['listOptions.continue'] = listOptionsContinue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowServiceApi - functional programming interface
 * @export
 */
export const WorkflowServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(namespace: string, body: WorkflowCreateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).createWorkflow(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).deleteWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;spec,status.phase\&quot;, \&quot;-status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, fields?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).getWorkflow(namespace, name, getOptionsResourceVersion, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflow(namespace: string, body: WorkflowLintRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).lintWorkflow(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;items.spec,items.status.phase\&quot;, \&quot;-items.status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, fields?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowList> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).listWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} podName 
         * @param {string} [logOptionsContainer] The container for which to stream logs. Defaults to only container if there is one container in the pod. +optional.
         * @param {boolean} [logOptionsFollow] Follow the log stream of the pod. Defaults to false. +optional.
         * @param {boolean} [logOptionsPrevious] Return previous terminated container logs. Defaults to false. +optional.
         * @param {string} [logOptionsSinceSeconds] A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. +optional.
         * @param {string} [logOptionsSinceTimeSeconds] Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
         * @param {number} [logOptionsSinceTimeNanos] Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
         * @param {boolean} [logOptionsTimestamps] If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. +optional.
         * @param {string} [logOptionsTailLines] If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime +optional.
         * @param {string} [logOptionsLimitBytes] If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podLogs(namespace: string, name: string, podName: string, logOptionsContainer?: string, logOptionsFollow?: boolean, logOptionsPrevious?: boolean, logOptionsSinceSeconds?: string, logOptionsSinceTimeSeconds?: string, logOptionsSinceTimeNanos?: number, logOptionsTimestamps?: boolean, logOptionsTailLines?: string, logOptionsLimitBytes?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).podLogs(namespace, name, podName, logOptionsContainer, logOptionsFollow, logOptionsPrevious, logOptionsSinceSeconds, logOptionsSinceTimeSeconds, logOptionsSinceTimeNanos, logOptionsTimestamps, logOptionsTailLines, logOptionsLimitBytes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitWorkflow(namespace: string, name: string, body: WorkflowResubmitRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).resubmitWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResumeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeWorkflow(namespace: string, name: string, body: WorkflowResumeRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).resumeWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowRetryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWorkflow(namespace: string, name: string, body: WorkflowRetryRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).retryWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowStopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWorkflow(namespace: string, name: string, body: WorkflowStopRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).stopWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowSuspendRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendWorkflow(namespace: string, name: string, body: WorkflowSuspendRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).suspendWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTerminateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateWorkflow(namespace: string, name: string, body: WorkflowTerminateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).terminateWorkflow(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowServiceApiAxiosParamCreator(configuration).watchWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowServiceApi - factory interface
 * @export
 */
export const WorkflowServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(namespace: string, body: WorkflowCreateRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).createWorkflow(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): AxiosPromise<object> {
            return WorkflowServiceApiFp(configuration).deleteWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;spec,status.phase\&quot;, \&quot;-status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, fields?: string, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).getWorkflow(namespace, name, getOptionsResourceVersion, fields, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflow(namespace: string, body: WorkflowLintRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).lintWorkflow(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;items.spec,items.status.phase\&quot;, \&quot;-items.status.nodes\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, fields?: string, options?: any): AxiosPromise<WorkflowList> {
            return WorkflowServiceApiFp(configuration).listWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, fields, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} podName 
         * @param {string} [logOptionsContainer] The container for which to stream logs. Defaults to only container if there is one container in the pod. +optional.
         * @param {boolean} [logOptionsFollow] Follow the log stream of the pod. Defaults to false. +optional.
         * @param {boolean} [logOptionsPrevious] Return previous terminated container logs. Defaults to false. +optional.
         * @param {string} [logOptionsSinceSeconds] A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. +optional.
         * @param {string} [logOptionsSinceTimeSeconds] Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
         * @param {number} [logOptionsSinceTimeNanos] Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
         * @param {boolean} [logOptionsTimestamps] If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. +optional.
         * @param {string} [logOptionsTailLines] If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime +optional.
         * @param {string} [logOptionsLimitBytes] If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podLogs(namespace: string, name: string, podName: string, logOptionsContainer?: string, logOptionsFollow?: boolean, logOptionsPrevious?: boolean, logOptionsSinceSeconds?: string, logOptionsSinceTimeSeconds?: string, logOptionsSinceTimeNanos?: number, logOptionsTimestamps?: boolean, logOptionsTailLines?: string, logOptionsLimitBytes?: string, options?: any): AxiosPromise<object> {
            return WorkflowServiceApiFp(configuration).podLogs(namespace, name, podName, logOptionsContainer, logOptionsFollow, logOptionsPrevious, logOptionsSinceSeconds, logOptionsSinceTimeSeconds, logOptionsSinceTimeNanos, logOptionsTimestamps, logOptionsTailLines, logOptionsLimitBytes, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resubmitWorkflow(namespace: string, name: string, body: WorkflowResubmitRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).resubmitWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowResumeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeWorkflow(namespace: string, name: string, body: WorkflowResumeRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).resumeWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowRetryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryWorkflow(namespace: string, name: string, body: WorkflowRetryRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).retryWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowStopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWorkflow(namespace: string, name: string, body: WorkflowStopRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).stopWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowSuspendRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendWorkflow(namespace: string, name: string, body: WorkflowSuspendRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).suspendWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTerminateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateWorkflow(namespace: string, name: string, body: WorkflowTerminateRequest, options?: any): AxiosPromise<Workflow> {
            return WorkflowServiceApiFp(configuration).terminateWorkflow(namespace, name, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): AxiosPromise<object> {
            return WorkflowServiceApiFp(configuration).watchWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowServiceApi - object-oriented interface
 * @export
 * @class WorkflowServiceApi
 * @extends {BaseAPI}
 */
export class WorkflowServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} namespace 
     * @param {WorkflowCreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public createWorkflow(namespace: string, body: WorkflowCreateRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).createWorkflow(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
     * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
     * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
     * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
     * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
     * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public deleteWorkflow(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any) {
        return WorkflowServiceApiFp(this.configuration).deleteWorkflow(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;spec,status.phase\&quot;, \&quot;-status.nodes\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public getWorkflow(namespace: string, name: string, getOptionsResourceVersion?: string, fields?: string, options?: any) {
        return WorkflowServiceApiFp(this.configuration).getWorkflow(namespace, name, getOptionsResourceVersion, fields, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {WorkflowLintRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public lintWorkflow(namespace: string, body: WorkflowLintRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).lintWorkflow(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
     * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
     * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
     * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
     * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
     * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {string} [fields] Fields to be included or excluded in the response. e.g. \&quot;items.spec,items.status.phase\&quot;, \&quot;-items.status.nodes\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public listWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, fields?: string, options?: any) {
        return WorkflowServiceApiFp(this.configuration).listWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, fields, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} podName 
     * @param {string} [logOptionsContainer] The container for which to stream logs. Defaults to only container if there is one container in the pod. +optional.
     * @param {boolean} [logOptionsFollow] Follow the log stream of the pod. Defaults to false. +optional.
     * @param {boolean} [logOptionsPrevious] Return previous terminated container logs. Defaults to false. +optional.
     * @param {string} [logOptionsSinceSeconds] A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. +optional.
     * @param {string} [logOptionsSinceTimeSeconds] Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @param {number} [logOptionsSinceTimeNanos] Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @param {boolean} [logOptionsTimestamps] If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. +optional.
     * @param {string} [logOptionsTailLines] If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime +optional.
     * @param {string} [logOptionsLimitBytes] If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public podLogs(namespace: string, name: string, podName: string, logOptionsContainer?: string, logOptionsFollow?: boolean, logOptionsPrevious?: boolean, logOptionsSinceSeconds?: string, logOptionsSinceTimeSeconds?: string, logOptionsSinceTimeNanos?: number, logOptionsTimestamps?: boolean, logOptionsTailLines?: string, logOptionsLimitBytes?: string, options?: any) {
        return WorkflowServiceApiFp(this.configuration).podLogs(namespace, name, podName, logOptionsContainer, logOptionsFollow, logOptionsPrevious, logOptionsSinceSeconds, logOptionsSinceTimeSeconds, logOptionsSinceTimeNanos, logOptionsTimestamps, logOptionsTailLines, logOptionsLimitBytes, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowResubmitRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public resubmitWorkflow(namespace: string, name: string, body: WorkflowResubmitRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).resubmitWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowResumeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public resumeWorkflow(namespace: string, name: string, body: WorkflowResumeRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).resumeWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowRetryRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public retryWorkflow(namespace: string, name: string, body: WorkflowRetryRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).retryWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowStopRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public stopWorkflow(namespace: string, name: string, body: WorkflowStopRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).stopWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowSuspendRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public suspendWorkflow(namespace: string, name: string, body: WorkflowSuspendRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).suspendWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowTerminateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public terminateWorkflow(namespace: string, name: string, body: WorkflowTerminateRequest, options?: any) {
        return WorkflowServiceApiFp(this.configuration).terminateWorkflow(namespace, name, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
     * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
     * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
     * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
     * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
     * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowServiceApi
     */
    public watchWorkflows(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any) {
        return WorkflowServiceApiFp(this.configuration).watchWorkflows(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(this.axios, this.basePath);
    }

}


/**
 * WorkflowTemplateServiceApi - axios parameter creator
 * @export
 */
export const WorkflowTemplateServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate(namespace: string, body: WorkflowTemplateCreateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createWorkflowTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createWorkflowTemplate.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteWorkflowTemplate.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteWorkflowTemplate.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deleteOptionsGracePeriodSeconds !== undefined) {
                localVarQueryParameter['deleteOptions.gracePeriodSeconds'] = deleteOptionsGracePeriodSeconds;
            }

            if (deleteOptionsPreconditionsUid !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.uid'] = deleteOptionsPreconditionsUid;
            }

            if (deleteOptionsPreconditionsResourceVersion !== undefined) {
                localVarQueryParameter['deleteOptions.preconditions.resourceVersion'] = deleteOptionsPreconditionsResourceVersion;
            }

            if (deleteOptionsOrphanDependents !== undefined) {
                localVarQueryParameter['deleteOptions.orphanDependents'] = deleteOptionsOrphanDependents;
            }

            if (deleteOptionsPropagationPolicy !== undefined) {
                localVarQueryParameter['deleteOptions.propagationPolicy'] = deleteOptionsPropagationPolicy;
            }

            if (deleteOptionsDryRun) {
                localVarQueryParameter['deleteOptions.dryRun'] = deleteOptionsDryRun;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplate(namespace: string, name: string, getOptionsResourceVersion?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getWorkflowTemplate.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getWorkflowTemplate.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getOptionsResourceVersion !== undefined) {
                localVarQueryParameter['getOptions.resourceVersion'] = getOptionsResourceVersion;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflowTemplate(namespace: string, body: WorkflowTemplateLintRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling lintWorkflowTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling lintWorkflowTemplate.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}/lint`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowTemplates(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling listWorkflowTemplates.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (listOptionsLabelSelector !== undefined) {
                localVarQueryParameter['listOptions.labelSelector'] = listOptionsLabelSelector;
            }

            if (listOptionsFieldSelector !== undefined) {
                localVarQueryParameter['listOptions.fieldSelector'] = listOptionsFieldSelector;
            }

            if (listOptionsWatch !== undefined) {
                localVarQueryParameter['listOptions.watch'] = listOptionsWatch;
            }

            if (listOptionsAllowWatchBookmarks !== undefined) {
                localVarQueryParameter['listOptions.allowWatchBookmarks'] = listOptionsAllowWatchBookmarks;
            }

            if (listOptionsResourceVersion !== undefined) {
                localVarQueryParameter['listOptions.resourceVersion'] = listOptionsResourceVersion;
            }

            if (listOptionsTimeoutSeconds !== undefined) {
                localVarQueryParameter['listOptions.timeoutSeconds'] = listOptionsTimeoutSeconds;
            }

            if (listOptionsLimit !== undefined) {
                localVarQueryParameter['listOptions.limit'] = listOptionsLimit;
            }

            if (listOptionsContinue !== undefined) {
                localVarQueryParameter['listOptions.continue'] = listOptionsContinue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTemplateUpdateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowTemplate(namespace: string, name: string, body: WorkflowTemplateUpdateRequest, options: any = {}): RequestArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateWorkflowTemplate.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateWorkflowTemplate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateWorkflowTemplate.');
            }
            const localVarPath = `/api/v1/workflow-templates/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowTemplateServiceApi - functional programming interface
 * @export
 */
export const WorkflowTemplateServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate(namespace: string, body: WorkflowTemplateCreateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplate> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).createWorkflowTemplate(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).deleteWorkflowTemplate(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplate(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplate> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).getWorkflowTemplate(namespace, name, getOptionsResourceVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflowTemplate(namespace: string, body: WorkflowTemplateLintRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplate> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).lintWorkflowTemplate(namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowTemplates(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplateList> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).listWorkflowTemplates(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTemplateUpdateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowTemplate(namespace: string, name: string, body: WorkflowTemplateUpdateRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowTemplate> {
            const localVarAxiosArgs = WorkflowTemplateServiceApiAxiosParamCreator(configuration).updateWorkflowTemplate(namespace, name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowTemplateServiceApi - factory interface
 * @export
 */
export const WorkflowTemplateServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateCreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowTemplate(namespace: string, body: WorkflowTemplateCreateRequest, options?: any): AxiosPromise<WorkflowTemplate> {
            return WorkflowTemplateServiceApiFp(configuration).createWorkflowTemplate(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
         * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
         * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
         * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
         * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
         * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflowTemplate(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any): AxiosPromise<object> {
            return WorkflowTemplateServiceApiFp(configuration).deleteWorkflowTemplate(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowTemplate(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any): AxiosPromise<WorkflowTemplate> {
            return WorkflowTemplateServiceApiFp(configuration).getWorkflowTemplate(namespace, name, getOptionsResourceVersion, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {WorkflowTemplateLintRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lintWorkflowTemplate(namespace: string, body: WorkflowTemplateLintRequest, options?: any): AxiosPromise<WorkflowTemplate> {
            return WorkflowTemplateServiceApiFp(configuration).lintWorkflowTemplate(namespace, body, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
         * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
         * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
         * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
         * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
         * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
         * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
         * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowTemplates(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any): AxiosPromise<WorkflowTemplateList> {
            return WorkflowTemplateServiceApiFp(configuration).listWorkflowTemplates(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {WorkflowTemplateUpdateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflowTemplate(namespace: string, name: string, body: WorkflowTemplateUpdateRequest, options?: any): AxiosPromise<WorkflowTemplate> {
            return WorkflowTemplateServiceApiFp(configuration).updateWorkflowTemplate(namespace, name, body, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowTemplateServiceApi - object-oriented interface
 * @export
 * @class WorkflowTemplateServiceApi
 * @extends {BaseAPI}
 */
export class WorkflowTemplateServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} namespace 
     * @param {WorkflowTemplateCreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public createWorkflowTemplate(namespace: string, body: WorkflowTemplateCreateRequest, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).createWorkflowTemplate(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [deleteOptionsGracePeriodSeconds] The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. +optional.
     * @param {string} [deleteOptionsPreconditionsUid] Specifies the target UID. +optional.
     * @param {string} [deleteOptionsPreconditionsResourceVersion] Specifies the target ResourceVersion +optional.
     * @param {boolean} [deleteOptionsOrphanDependents] Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. +optional.
     * @param {string} [deleteOptionsPropagationPolicy] Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. +optional.
     * @param {Array<string>} [deleteOptionsDryRun] When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed +optional.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public deleteWorkflowTemplate(namespace: string, name: string, deleteOptionsGracePeriodSeconds?: string, deleteOptionsPreconditionsUid?: string, deleteOptionsPreconditionsResourceVersion?: string, deleteOptionsOrphanDependents?: boolean, deleteOptionsPropagationPolicy?: string, deleteOptionsDryRun?: Array<string>, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).deleteWorkflowTemplate(namespace, name, deleteOptionsGracePeriodSeconds, deleteOptionsPreconditionsUid, deleteOptionsPreconditionsResourceVersion, deleteOptionsOrphanDependents, deleteOptionsPropagationPolicy, deleteOptionsDryRun, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {string} [getOptionsResourceVersion] When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public getWorkflowTemplate(namespace: string, name: string, getOptionsResourceVersion?: string, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).getWorkflowTemplate(namespace, name, getOptionsResourceVersion, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {WorkflowTemplateLintRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public lintWorkflowTemplate(namespace: string, body: WorkflowTemplateLintRequest, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).lintWorkflowTemplate(namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} [listOptionsLabelSelector] A selector to restrict the list of returned objects by their labels. Defaults to everything. +optional.
     * @param {string} [listOptionsFieldSelector] A selector to restrict the list of returned objects by their fields. Defaults to everything. +optional.
     * @param {boolean} [listOptionsWatch] Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. +optional.
     * @param {boolean} [listOptionsAllowWatchBookmarks] allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.  +optional
     * @param {string} [listOptionsResourceVersion] When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. +optional.
     * @param {string} [listOptionsTimeoutSeconds] Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. +optional.
     * @param {string} [listOptionsLimit] limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param {string} [listOptionsContinue] The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public listWorkflowTemplates(namespace: string, listOptionsLabelSelector?: string, listOptionsFieldSelector?: string, listOptionsWatch?: boolean, listOptionsAllowWatchBookmarks?: boolean, listOptionsResourceVersion?: string, listOptionsTimeoutSeconds?: string, listOptionsLimit?: string, listOptionsContinue?: string, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).listWorkflowTemplates(namespace, listOptionsLabelSelector, listOptionsFieldSelector, listOptionsWatch, listOptionsAllowWatchBookmarks, listOptionsResourceVersion, listOptionsTimeoutSeconds, listOptionsLimit, listOptionsContinue, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {WorkflowTemplateUpdateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowTemplateServiceApi
     */
    public updateWorkflowTemplate(namespace: string, name: string, body: WorkflowTemplateUpdateRequest, options?: any) {
        return WorkflowTemplateServiceApiFp(this.configuration).updateWorkflowTemplate(namespace, name, body, options)(this.axios, this.basePath);
    }

}


